---
phase: 41-auto-save
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/CMPController.cs
  - Data/ApplicationDbContext.cs
  - Migrations/[generated]_AddUniqueConstraintPackageUserResponse.cs
autonomous: true

must_haves:
  truths:
    - "SaveAnswer uses ExecuteUpdateAsync atomic upsert — no manual FirstOrDefaultAsync check-then-insert"
    - "PackageUserResponse table has a UNIQUE constraint on (AssessmentSessionId, PackageQuestionId) in the database"
    - "SaveLegacyAnswer endpoint exists and writes UserResponse rows for legacy exam path using atomic upsert"
    - "Both endpoints validate session ownership and reject closed sessions before writing"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "SaveAnswer (hardened) + SaveLegacyAnswer (new)"
      contains: "ExecuteUpdateAsync"
    - path: "Data/ApplicationDbContext.cs"
      provides: "UNIQUE index on PackageUserResponse (AssessmentSessionId, PackageQuestionId)"
      contains: "IsUnique()"
    - path: "Migrations/"
      provides: "EF migration applying the unique constraint"
      contains: "AddUniqueConstraintPackageUserResponse"
  key_links:
    - from: "Controllers/CMPController.cs SaveAnswer"
      to: "_context.PackageUserResponses"
      via: "ExecuteUpdateAsync + conditional Add"
      pattern: "ExecuteUpdateAsync"
    - from: "Controllers/CMPController.cs SaveLegacyAnswer"
      to: "_context.UserResponses"
      via: "ExecuteUpdateAsync + conditional Add"
      pattern: "SaveLegacyAnswer"
    - from: "Data/ApplicationDbContext.cs PackageUserResponse entity"
      to: "database UNIQUE index"
      via: "HasIndex(...).IsUnique()"
      pattern: "IsUnique"
---

<objective>
Harden the existing SaveAnswer endpoint with an atomic upsert and add a UNIQUE database constraint on PackageUserResponse, then create a new SaveLegacyAnswer endpoint for the legacy exam path.

Purpose: Prevent duplicate PackageUserResponse rows under concurrent saves (rapid clicks, multiple tabs) and give the legacy exam path its own auto-save endpoint so Phase 41 frontend can target both paths correctly.

Output:
- SaveAnswer rewritten to use ExecuteUpdateAsync (atomic update-or-insert, no change tracking race condition)
- UNIQUE constraint on PackageUserResponse(AssessmentSessionId, PackageQuestionId) via EF migration
- New [HttpPost] SaveLegacyAnswer(int sessionId, int questionId, int optionId) writing to UserResponse table using the same atomic upsert pattern
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Controllers/CMPController.cs
@Data/ApplicationDbContext.cs
@Models/UserResponse.cs
@Models/PackageUserResponse.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden SaveAnswer with ExecuteUpdateAsync and add UNIQUE constraint migration</name>
  <files>Controllers/CMPController.cs, Data/ApplicationDbContext.cs</files>
  <action>
**In CMPController.cs — replace the body of SaveAnswer (lines ~1049-1069):**

Replace the current manual check-then-insert pattern (FirstOrDefaultAsync + if/else) with ExecuteUpdateAsync:

```csharp
// Atomic upsert: update existing row, or insert if none exists
var updatedCount = await _context.PackageUserResponses
    .Where(r => r.AssessmentSessionId == sessionId && r.PackageQuestionId == questionId)
    .ExecuteUpdateAsync(s => s
        .SetProperty(r => r.PackageOptionId, optionId)
        .SetProperty(r => r.SubmittedAt, DateTime.UtcNow)
    );

if (updatedCount == 0)
{
    _context.PackageUserResponses.Add(new PackageUserResponse
    {
        AssessmentSessionId = sessionId,
        PackageQuestionId = questionId,
        PackageOptionId = optionId,
        SubmittedAt = DateTime.UtcNow
    });
    await _context.SaveChangesAsync();
}

return Json(new { success = true });
```

Keep all existing guards above this block unchanged (FindAsync session, GetUserAsync, ownership check `session.UserId != user.Id`, closed-session check).

Remove the old `await _context.SaveChangesAsync();` that was at the end of the old pattern (the new pattern only calls SaveChangesAsync inside the `if (updatedCount == 0)` branch).

**In Data/ApplicationDbContext.cs — add IsUnique() to the PackageUserResponse index (line ~407):**

Change:
```csharp
entity.HasIndex(r => new { r.AssessmentSessionId, r.PackageQuestionId });
```
To:
```csharp
entity.HasIndex(r => new { r.AssessmentSessionId, r.PackageQuestionId })
    .IsUnique();
```

**Then run the EF migration** to apply the unique constraint to the database:
```bash
cd /c/Users/rinoa/Desktop/PortalHC_KPB
dotnet ef migrations add AddUniqueConstraintPackageUserResponse
dotnet ef database update
```

Verify migration was created and applied successfully.
  </action>
  <verify>
1. Read CMPController.cs around SaveAnswer — confirm `ExecuteUpdateAsync` is present, no `FirstOrDefaultAsync` remains in SaveAnswer body.
2. Read ApplicationDbContext.cs around line 407 — confirm `.IsUnique()` is present on the PackageUserResponse composite index.
3. Run `dotnet ef migrations list` — confirm `AddUniqueConstraintPackageUserResponse` appears as the latest migration and is listed as Applied.
4. Run `dotnet build` — zero errors.
  </verify>
  <done>SaveAnswer uses ExecuteUpdateAsync; PackageUserResponse UNIQUE constraint exists in DB; build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create SaveLegacyAnswer endpoint for legacy exam path</name>
  <files>Controllers/CMPController.cs</files>
  <action>
Add a new `[HttpPost]` action to CMPController.cs immediately after the closing brace of `SaveAnswer` (after line ~1071).

The endpoint writes to `UserResponse` (legacy table). `UserResponse` schema: `Id`, `AssessmentSessionId`, `AssessmentQuestionId`, `SelectedOptionId` (int?, FK to AssessmentOption), `TextAnswer` (string?). No `SubmittedAt` field — do NOT try to set it.

Note: `questionId` maps to `AssessmentQuestionId`, `optionId` maps to `SelectedOptionId`.

```csharp
// --- SAVE LEGACY ANSWER (auto-save for legacy exam path → UserResponse) ---
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> SaveLegacyAnswer(int sessionId, int questionId, int optionId)
{
    var session = await _context.AssessmentSessions.FindAsync(sessionId);
    if (session == null) return NotFound();

    var user = await _userManager.GetUserAsync(User);
    if (user == null) return Challenge();

    // Only the session owner may save answers
    if (session.UserId != user.Id)
        return Json(new { success = false, error = "Unauthorized" });

    // Session must still be in progress
    if (session.Status == "Completed" || session.Status == "Abandoned")
        return Json(new { success = false, error = "Session already closed" });

    // Atomic upsert: update existing row, or insert if none exists
    var updatedCount = await _context.UserResponses
        .Where(r => r.AssessmentSessionId == sessionId && r.AssessmentQuestionId == questionId)
        .ExecuteUpdateAsync(s => s
            .SetProperty(r => r.SelectedOptionId, optionId)
        );

    if (updatedCount == 0)
    {
        _context.UserResponses.Add(new UserResponse
        {
            AssessmentSessionId = sessionId,
            AssessmentQuestionId = questionId,
            SelectedOptionId = optionId
        });
        await _context.SaveChangesAsync();
    }

    return Json(new { success = true });
}
```

Ensure the `using` statement for `Microsoft.EntityFrameworkCore` is already present (it is — ExecuteUpdateAsync is already available via Task 1). No additional usings needed.

Confirm `_context.UserResponses` is a valid DbSet (it is — ApplicationDbContext already has `DbSet<UserResponse> UserResponses`).
  </action>
  <verify>
1. Read CMPController.cs — confirm `SaveLegacyAnswer` action exists with `[HttpPost]` and `[ValidateAntiForgeryToken]` attributes.
2. Confirm the action contains `ExecuteUpdateAsync` targeting `_context.UserResponses`.
3. Run `dotnet build` — zero errors.
4. Run `dotnet ef migrations list` — no unexpected new migrations (SaveLegacyAnswer is code-only, no schema change needed).
  </verify>
  <done>SaveLegacyAnswer endpoint exists, handles session ownership, uses atomic upsert on UserResponse, build passes with zero errors.</done>
</task>

</tasks>

<verification>
After both tasks:
- `dotnet build` produces zero errors and zero warnings about nullable/unresolved references in the modified methods
- CMPController.cs has both `SaveAnswer` (with ExecuteUpdateAsync on PackageUserResponses) and `SaveLegacyAnswer` (with ExecuteUpdateAsync on UserResponses) in the same controller
- `dotnet ef migrations list` shows `AddUniqueConstraintPackageUserResponse` as Applied
- Schema inspection: `SELECT * FROM [dbo].[PackageUserResponses]` — table can accept the constraint without existing duplicate violations (verify with: `SELECT AssessmentSessionId, PackageQuestionId, COUNT(*) FROM PackageUserResponses GROUP BY AssessmentSessionId, PackageQuestionId HAVING COUNT(*) > 1` should return 0 rows)
</verification>

<success_criteria>
- SaveAnswer endpoint uses ExecuteUpdateAsync (atomic); no FirstOrDefaultAsync in SaveAnswer body
- UNIQUE constraint on PackageUserResponse(AssessmentSessionId, PackageQuestionId) is active in the database
- SaveLegacyAnswer endpoint exists, validates ownership, uses ExecuteUpdateAsync on UserResponse
- `dotnet build` passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/41-auto-save/41-01-SUMMARY.md` using the standard summary template.
</output>
