---
phase: 42-session-resume
plan: 02
type: execute
wave: 2
depends_on: ["42-01"]
files_modified:
  - Controllers/CMPController.cs
autonomous: true

must_haves:
  truths:
    - "POST /CMP/UpdateSessionProgress saves ElapsedSeconds and LastActivePage atomically and rejects closed/unauthorized sessions"
    - "StartExam GET populates ViewBag.IsResume, ViewBag.LastActivePage, ViewBag.RemainingSeconds, ViewBag.SavedAnswers, ViewBag.ElapsedSeconds for in-progress sessions"
    - "StartExam GET detects stale question set (SavedQuestionCount mismatch) and sets TempData error + redirects back to Assessment"
    - "StartExam GET detects expired exam (RemainingSeconds <= 0) and sets ViewBag.ExamExpired = true"
    - "StartExam GET records SavedQuestionCount on first exam load (when assignment is newly created)"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "UpdateSessionProgress endpoint + modified StartExam GET"
      contains: "UpdateSessionProgress"
  key_links:
    - from: "Controllers/CMPController.cs UpdateSessionProgress"
      to: "AssessmentSessions table"
      via: "ExecuteUpdateAsync on ElapsedSeconds + LastActivePage"
      pattern: "ExecuteUpdateAsync"
    - from: "Controllers/CMPController.cs StartExam"
      to: "PackageUserResponses table"
      via: "LINQ query for saved answers JSON"
      pattern: "SavedAnswers"
---

<objective>
Add UpdateSessionProgress POST endpoint (saves elapsed time + current page atomically) and modify the StartExam GET to detect in-progress sessions, run stale-question check, calculate remaining time from ElapsedSeconds, load saved answers, and set all ViewBag flags the frontend needs. This is the complete backend for session resume.

Purpose: Frontend (Plan 03) reads ViewBag.IsResume, ViewBag.RemainingSeconds, ViewBag.SavedAnswers from the server. Without this plan, the frontend has nothing to read.
Output: One new POST endpoint + enhanced StartExam GET. All resume logic lives server-side.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/42-session-resume/42-CONTEXT.md
@.planning/phases/42-session-resume/42-RESEARCH.md
@.planning/phases/42-session-resume/42-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UpdateSessionProgress POST endpoint to CMPController</name>
  <files>Controllers/CMPController.cs</files>
  <action>
Find the `CheckExamStatus` GET endpoint (around line 1112 in CMPController.cs). Insert the `UpdateSessionProgress` endpoint directly after the closing brace of `CheckExamStatus` (before the `ReshufflePackage` endpoint at ~line 1143).

```csharp
// --- UPDATE SESSION PROGRESS (saves elapsed time + current page for resume) ---
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> UpdateSessionProgress(int sessionId, int elapsedSeconds, int currentPage)
{
    var session = await _context.AssessmentSessions.FindAsync(sessionId);
    if (session == null) return NotFound();

    var user = await _userManager.GetUserAsync(User);
    if (user == null) return Challenge();

    // Session ownership check (same pattern as SaveAnswer)
    if (session.UserId != user.Id)
        return Json(new { success = false, error = "Unauthorized" });

    // Skip update if session already closed
    if (session.Status == "Completed" || session.Status == "Abandoned")
        return Json(new { success = false, error = "Session already closed" });

    // Atomic update of elapsed time and last active page
    var updated = await _context.AssessmentSessions
        .Where(s => s.Id == sessionId)
        .ExecuteUpdateAsync(s => s
            .SetProperty(r => r.ElapsedSeconds, elapsedSeconds)
            .SetProperty(r => r.LastActivePage, currentPage)
            .SetProperty(r => r.UpdatedAt, DateTime.UtcNow)
        );

    if (updated == 0)
        return Json(new { success = false, error = "Update failed" });

    return Json(new { success = true });
}
```

**Guards to enforce:**
- Session must exist (FindAsync)
- User must be authenticated (GetUserAsync)
- User must own the session (UserId != user.Id → return Json error, consistent with SaveAnswer pattern)
- Session must not be Completed or Abandoned (closed sessions do not accept progress updates)
- Use ExecuteUpdateAsync for atomic update (same pattern as SaveAnswer in Phase 41)
- Do NOT use FindAsync + property mutation + SaveChangesAsync — avoids EF tracking race condition

No other changes to this task.
  </action>
  <verify>
1. Read Controllers/CMPController.cs around the inserted section — confirms UpdateSessionProgress method exists with correct signature.
2. `dotnet build C:/Users/rinoa/Desktop/PortalHC_KPB/PortalHC_KPB.csproj --no-restore 2>&1 | tail -5` — 0 errors.
  </verify>
  <done>UpdateSessionProgress POST endpoint exists in CMPController.cs, compiles cleanly, and follows the same guard + ExecuteUpdateAsync pattern as SaveAnswer.</done>
</task>

<task type="auto">
  <name>Task 2: Modify StartExam GET — resume detection, stale check, ViewBag flags, saved answers</name>
  <files>Controllers/CMPController.cs</files>
  <action>
In CMPController.cs, find the StartExam GET method (starts at approximately line 2707). This method currently:
1. Loads assessment + user auth
2. Auto-transitions Upcoming → Open
3. Checks Completed/Abandoned/token/window gate
4. Marks InProgress on first load
5. Loads packages and builds vm
6. Returns View(vm)

Make the following targeted modifications:

**MODIFICATION A — Record SavedQuestionCount on first package assignment (in the package path, after the new assignment is created):**

Locate the block inside `if (packages.Any())` where `assignment == null` and a new `UserPackageAssignment` is created and saved. Immediately after `await _context.SaveChangesAsync();` (the one that saves the new assignment), add:

```csharp
// Record question count for stale-question detection on resume (RESUME-03 safety net)
assignment.SavedQuestionCount = selectedPackage.Questions.Count;
await _context.SaveChangesAsync();
```

**MODIFICATION B — Stale question check on resume (in the package path, after assignment is loaded/created):**

After the block that loads `assignedPackage` (the `var assignedPackage = packages.First(...)` line), add:

```csharp
// Stale question set check: compare count at session start vs. now
// HC cannot normally edit questions once a session is active (existing guard), but this is a defensive safety net
if (assessment.StartedAt != null && assignment.SavedQuestionCount.HasValue &&
    assignment.SavedQuestionCount.Value != assignedPackage.Questions.Count)
{
    // Clear saved progress so worker gets a clean restart when HC resets
    await _context.AssessmentSessions
        .Where(s => s.Id == id)
        .ExecuteUpdateAsync(s => s
            .SetProperty(r => r.ElapsedSeconds, 0)
            .SetProperty(r => r.LastActivePage, (int?)null)
        );

    TempData["Error"] = "Soal ujian telah berubah. Hubungi HC untuk mengatur ulang ujian Anda.";
    return RedirectToAction("Assessment");
}
```

**MODIFICATION C — Load saved answers and set resume ViewBag flags (in the package path, after building the vm, before `return View(vm)`):**

After the `vm = new PackageExamViewModel { ... }` block in the package path, add:

```csharp
// Resume state: set ViewBag flags for frontend
bool isResume = assessment.StartedAt != null;
int durationSeconds = assessment.DurationMinutes * 60;
int elapsedSec = assessment.ElapsedSeconds;
int remainingSeconds = durationSeconds - elapsedSec;

ViewBag.IsResume = isResume;
ViewBag.LastActivePage = assessment.LastActivePage ?? 0;
ViewBag.ElapsedSeconds = elapsedSec;
ViewBag.RemainingSeconds = remainingSeconds;
ViewBag.ExamExpired = isResume && remainingSeconds <= 0;

// Load previously saved answers for pre-population (package path)
if (isResume)
{
    var savedAnswers = await _context.PackageUserResponses
        .Where(r => r.AssessmentSessionId == id)
        .ToDictionaryAsync(r => r.PackageQuestionId, r => r.PackageOptionId ?? 0);
    ViewBag.SavedAnswers = System.Text.Json.JsonSerializer.Serialize(savedAnswers);
}
else
{
    ViewBag.SavedAnswers = "{}";
}
```

**MODIFICATION D — Set the same resume ViewBag flags for the legacy path (in the else branch, after `vm = new PackageExamViewModel { ... }` for legacy, before `return View(vm)`):**

```csharp
// Resume state for legacy path
bool isResumeLegacy = assessment.StartedAt != null;
int durationSecondsLegacy = assessment.DurationMinutes * 60;
int elapsedSecLegacy = assessment.ElapsedSeconds;
int remainingSecondsLegacy = durationSecondsLegacy - elapsedSecLegacy;

ViewBag.IsResume = isResumeLegacy;
ViewBag.LastActivePage = assessment.LastActivePage ?? 0;
ViewBag.ElapsedSeconds = elapsedSecLegacy;
ViewBag.RemainingSeconds = remainingSecondsLegacy;
ViewBag.ExamExpired = isResumeLegacy && remainingSecondsLegacy <= 0;

// Load previously saved answers for pre-population (legacy path)
if (isResumeLegacy)
{
    var savedAnswersLegacy = await _context.UserResponses
        .Where(r => r.AssessmentSessionId == id)
        .ToDictionaryAsync(r => r.AssessmentQuestionId, r => r.SelectedOptionId ?? 0);
    ViewBag.SavedAnswers = System.Text.Json.JsonSerializer.Serialize(savedAnswersLegacy);
}
else
{
    ViewBag.SavedAnswers = "{}";
}
```

**Important notes:**
- `isResume = assessment.StartedAt != null` is true even on first load (because Modification marks InProgress before this code runs). The first time through: StartedAt just got set, ElapsedSeconds = 0, so RemainingSeconds = full duration, ExamExpired = false, SavedAnswers = {} — this is correct behavior (no resume modal shown, timer starts full).
- The resume modal in the frontend is triggered by `IsResume && LastActivePage > 0` (worker actually navigated away previously). On first load, LastActivePage is null/0 so no modal.
- For the stale check: only runs when `assessment.StartedAt != null` (i.e., already started before this request) AND `SavedQuestionCount.HasValue`. A brand new session (just marked InProgress above) has StartedAt just set — the assignment was also just created with SavedQuestionCount set. This means the stale check would pass (counts match) on first load. Correct.
- The stale check block must come AFTER the `var assignedPackage = ...` line so both `assignment.SavedQuestionCount` and `assignedPackage.Questions.Count` are available.
  </action>
  <verify>
1. `dotnet build C:/Users/rinoa/Desktop/PortalHC_KPB/PortalHC_KPB.csproj --no-restore 2>&1 | tail -5` — 0 errors.
2. Read the modified StartExam method and confirm: ViewBag.IsResume, ViewBag.RemainingSeconds, ViewBag.SavedAnswers, ViewBag.ExamExpired are all set in both package and legacy paths.
3. Confirm UpdateSessionProgress also compiles (from Task 1).
  </verify>
  <done>StartExam GET computes remaining time as (DurationMinutes * 60) - ElapsedSeconds, loads saved answers as JSON dict, sets all five ViewBag flags (IsResume, LastActivePage, ElapsedSeconds, RemainingSeconds, ExamExpired). Stale-question check on package path blocks with TempData error + redirect. SavedQuestionCount recorded on first package assignment. Legacy path has same ViewBag flags with UserResponses query. Build: 0 errors.</done>
</task>

</tasks>

<verification>
- `dotnet build` exits 0
- Read CMPController.cs: confirm `UpdateSessionProgress` method exists (lines ~1142-1175)
- Grep CMPController.cs for "ViewBag.IsResume" — appears in both package path and legacy path
- Grep CMPController.cs for "SavedQuestionCount" — appears in assignment creation block and stale-check block
- Grep CMPController.cs for "ExamExpired" — set as `remainingSeconds <= 0`
</verification>

<success_criteria>
Backend is fully ready for session resume. UpdateSessionProgress endpoint handles periodic elapsed-time saves from frontend. StartExam GET provides all ViewBag data the frontend needs to: show resume modal, initialize timer at correct remaining time, pre-populate answers, handle expired exams, and detect stale question sets.
</success_criteria>

<output>
After completion, create `.planning/phases/42-session-resume/42-02-SUMMARY.md`
</output>
