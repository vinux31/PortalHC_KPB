---
phase: 46-attempt-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Models/AssessmentAttemptHistory.cs
  - Data/ApplicationDbContext.cs
  - Controllers/CMPController.cs
autonomous: true
requirements:
  - HIST-01
must_haves:
  truths:
    - "AssessmentAttemptHistory table exists in the database after migration is applied"
    - "Resetting a Completed session creates one row in AssessmentAttemptHistory before clearing the session"
    - "Resetting a non-Completed session (Open, InProgress, Abandoned) produces no history row"
    - "AttemptNumber on the archived row equals count-of-existing-archives-for-that-user+title + 1"
  artifacts:
    - path: "Models/AssessmentAttemptHistory.cs"
      provides: "Archive record model with all required fields"
      contains: "public class AssessmentAttemptHistory"
    - path: "Data/ApplicationDbContext.cs"
      provides: "DbSet registration and EF Core configuration"
      contains: "DbSet<AssessmentAttemptHistory>"
    - path: "Controllers/CMPController.cs"
      provides: "Archival logic in ResetAssessment action"
      contains: "if (assessment.Status == \"Completed\")"
  key_links:
    - from: "Controllers/CMPController.cs ResetAssessment"
      to: "_context.AssessmentAttemptHistory"
      via: "Save before clearing session fields"
      pattern: "AssessmentAttemptHistory\\.Add"
    - from: "Data/ApplicationDbContext.cs"
      to: "Models/AssessmentAttemptHistory.cs"
      via: "DbSet registration + OnModelCreating configuration"
      pattern: "DbSet<AssessmentAttemptHistory>"
---

<objective>
Create the AssessmentAttemptHistory data model, register it in DbContext, apply the EF Core migration, then modify ResetAssessment to archive Completed sessions before clearing.

Purpose: Establishes the persistent audit trail so that every reset of a completed assessment is preserved for the History tab.
Output: New table in database, archival logic in controller.
</objective>

<execution_context>
@C:/Users/Administrator/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Administrator/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key existing types the executor needs. No codebase exploration required. -->

From Models/AllWorkersHistoryRow.cs:
```csharp
public class AllWorkersHistoryRow
{
    public string WorkerName { get; set; } = "";
    public string? WorkerNIP { get; set; }
    public string RecordType { get; set; } = "";
    public string Title { get; set; } = "";
    public DateTime Date { get; set; }
    public string? Penyelenggara { get; set; }
    public int? Score { get; set; }
    public bool? IsPassed { get; set; }
    // AttemptNumber added in Plan 02
}
```

From Models/AssessmentSession.cs (relevant fields):
```csharp
public int Id { get; set; }
public string UserId { get; set; }
public ApplicationUser? User { get; set; }
public string Title { get; set; }
public string Category { get; set; }
public string Status { get; set; }  // "Open" | "InProgress" | "Completed" | "Abandoned"
public int? Score { get; set; }
public bool? IsPassed { get; set; }
public DateTime? StartedAt { get; set; }
public DateTime? CompletedAt { get; set; }
public DateTime Schedule { get; set; }
```

From Controllers/CMPController.cs — ResetAssessment (current, lines 598-669):
- Checks Status in ["Open", "InProgress", "Completed", "Abandoned"] before proceeding
- Deletes UserResponse, PackageUserResponse, UserPackageAssignment records
- Resets session fields: Status="Open", Score=null, IsPassed=null, CompletedAt=null, StartedAt=null, ElapsedSeconds=0, LastActivePage=null, Progress=0, UpdatedAt=DateTime.UtcNow
- Calls SaveChangesAsync() THEN audit log THEN redirect
- CRITICAL: archival must happen BEFORE the session fields are cleared and BEFORE SaveChangesAsync

From Data/ApplicationDbContext.cs — OnModelCreating pattern:
```csharp
builder.Entity<AuditLog>(entity =>
{
    entity.HasIndex(a => a.CreatedAt);
    entity.HasIndex(a => a.ActorUserId);
    entity.Property(a => a.CreatedAt).HasDefaultValueSql("GETUTCDATE()");
});
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: AssessmentAttemptHistory model + DbContext registration + migration</name>
  <files>
    Models/AssessmentAttemptHistory.cs
    Data/ApplicationDbContext.cs
  </files>
  <action>
Create Models/AssessmentAttemptHistory.cs with these exact fields (nothing more — do not archive UI state):
```csharp
using System.ComponentModel.DataAnnotations;

namespace HcPortal.Models
{
    public class AssessmentAttemptHistory
    {
        [Key]
        public int Id { get; set; }
        public int SessionId { get; set; }
        public string UserId { get; set; } = "";
        public ApplicationUser? User { get; set; }
        public string Title { get; set; } = "";
        public string Category { get; set; } = "";
        public int? Score { get; set; }
        public bool? IsPassed { get; set; }
        public DateTime? StartedAt { get; set; }
        public DateTime? CompletedAt { get; set; }
        public int AttemptNumber { get; set; }
        public DateTime ArchivedAt { get; set; } = DateTime.UtcNow;
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }
}
```

In Data/ApplicationDbContext.cs:
1. Add DbSet after the AuditLog DbSet line:
   `public DbSet<AssessmentAttemptHistory> AssessmentAttemptHistory { get; set; }`
2. Add entity configuration block in OnModelCreating (after AuditLog config):
```csharp
builder.Entity<AssessmentAttemptHistory>(entity =>
{
    entity.HasOne(h => h.User)
        .WithMany()
        .HasForeignKey(h => h.UserId)
        .OnDelete(DeleteBehavior.Cascade);

    entity.HasIndex(h => h.UserId);
    entity.HasIndex(h => new { h.UserId, h.Title });
    entity.Property(h => h.CreatedAt).HasDefaultValueSql("GETUTCDATE()");
});
```

Then run migration in the project directory:
```
cd C:\Users\Administrator\Desktop\PortalHC_KPB
dotnet ef migrations add AddAssessmentAttemptHistory
dotnet ef database update
```

Verify migration file was created in Migrations/ directory and database update succeeds.
  </action>
  <verify>
    dotnet build (0 errors); dotnet ef database update exits with "Done" and migration file exists in Migrations/ named *AddAssessmentAttemptHistory*
  </verify>
  <done>AssessmentAttemptHistory table exists in the database; DbSet is registered; build is clean</done>
</task>

<task type="auto">
  <name>Task 2: Archival logic in ResetAssessment</name>
  <files>
    Controllers/CMPController.cs
  </files>
  <action>
In CMPController.ResetAssessment (around line 615, after the status validation guard and BEFORE the UserResponse deletion block), insert archival logic:

```csharp
// Phase 46: Archive attempt data if session was Completed
if (assessment.Status == "Completed")
{
    int existingAttempts = await _context.AssessmentAttemptHistory
        .Where(h => h.UserId == assessment.UserId && h.Title == assessment.Title)
        .CountAsync();

    var attemptHistory = new AssessmentAttemptHistory
    {
        SessionId    = assessment.Id,
        UserId       = assessment.UserId,
        Title        = assessment.Title ?? "",
        Category     = assessment.Category ?? "",
        Score        = assessment.Score,
        IsPassed     = assessment.IsPassed,
        StartedAt    = assessment.StartedAt,
        CompletedAt  = assessment.CompletedAt,
        AttemptNumber = existingAttempts + 1,
        ArchivedAt   = DateTime.UtcNow
    };
    _context.AssessmentAttemptHistory.Add(attemptHistory);
}
```

Placement rules:
- Insert AFTER: `if (assessment == null) return NotFound();` block and the status validation guard
- Insert BEFORE: the UserResponse deletion block (// 1. Delete UserResponse records)
- The existing `await _context.SaveChangesAsync();` at line 649 will persist both the archive and the session reset in one transaction — do NOT add a separate SaveChangesAsync call

Important: assessment.Title and assessment.Category use null-coalescing (`?? ""`) because they are nullable strings in the model.
  </action>
  <verify>
    dotnet build (0 errors). Manual smoke test: in HC monitoring, reset a Completed session — verify AssessmentAttemptHistory table has 1 new row with correct Score, IsPassed, AttemptNumber=1. Reset an Open session — verify no new row added.
  </verify>
  <done>Reset on Completed session creates archive row with AttemptNumber=1 (first attempt) or N+1 (nth attempt); Reset on non-Completed session adds no row; build is clean</done>
</task>

</tasks>

<verification>
- `dotnet build` exits with 0 errors
- `dotnet ef database update` applied successfully (migration file present in Migrations/)
- Manual: reset a completed session — 1 row in AssessmentAttemptHistory with correct fields
- Manual: reset a non-completed (Open/InProgress) session — 0 rows added
- Subsequent reset of same session (now re-completed) — AttemptNumber increments to 2
</verification>

<success_criteria>
AssessmentAttemptHistory table is live in the database. ResetAssessment correctly archives Completed sessions and skips non-Completed sessions. AttemptNumber is sequential per worker+title.
</success_criteria>

<output>
After completion, create `.planning/phases/46-attempt-history/46-01-SUMMARY.md`
</output>
