---
phase: 03-kkj-cpdp-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Controllers/CMPController.cs
  - Data/SeedCompetencyMappings.cs
  - Program.cs
autonomous: true
must_haves:
  truths:
    - "When user passes an assessment, their competency levels are automatically updated based on mapping"
    - "Assessment-to-competency seed data maps existing categories to KKJ competencies"
    - "Competency levels only increase, never decrease on assessment completion"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "Auto-update logic in SubmitExam action"
      contains: "AssessmentCompetencyMap"
    - path: "Data/SeedCompetencyMappings.cs"
      provides: "Seed data for assessment-to-competency mappings"
      contains: "class SeedCompetencyMappings"
    - path: "Program.cs"
      provides: "Calls seed method on startup"
      contains: "SeedCompetencyMappings"
  key_links:
    - from: "Controllers/CMPController.cs"
      to: "Data/ApplicationDbContext.cs"
      via: "Queries AssessmentCompetencyMaps on exam submission"
      pattern: "AssessmentCompetencyMaps.*Where.*Category"
    - from: "Controllers/CMPController.cs"
      to: "Models/Competency/UserCompetencyLevel.cs"
      via: "Creates or updates UserCompetencyLevel records"
      pattern: "UserCompetencyLevels.Add|CurrentLevel.*LevelGranted"
    - from: "Data/SeedCompetencyMappings.cs"
      to: "Data/ApplicationDbContext.cs"
      via: "Seeds AssessmentCompetencyMap records"
      pattern: "AssessmentCompetencyMaps.AddRange"
---

<objective>
Wire assessment completion to automatic competency level updates, and seed initial assessment-to-competency mapping data so the system knows which assessments validate which KKJ competencies.

Purpose: This is the critical link between the assessment engine (Phase 1-2) and competency tracking (Phase 3). Without this, assessment results remain disconnected from KKJ competency levels. This plan closes Success Criterion 5 (assessment results linked to competencies) and partially closes Criterion 1 (levels updated based on assessment results).

Output: Enhanced SubmitExam action with auto-update logic, seed data with sensible initial mappings.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-kkj-cpdp-integration/03-RESEARCH.md
@.planning/phases/03-kkj-cpdp-integration/03-01-SUMMARY.md
@Controllers/CMPController.cs
@Models/Competency/AssessmentCompetencyMap.cs
@Models/Competency/UserCompetencyLevel.cs
@Data/ApplicationDbContext.cs
@Helpers/PositionTargetHelper.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auto-competency-update logic to SubmitExam</name>
  <files>
    Controllers/CMPController.cs
  </files>
  <action>
Add `using HcPortal.Models.Competency;` and `using HcPortal.Helpers;` to the top of CMPController.cs.

In the `SubmitExam` action, after the line `assessment.CompletedAt = DateTime.UtcNow;` and BEFORE `_context.AssessmentSessions.Update(assessment);`, add the competency auto-update block:

```csharp
// ========== AUTO-UPDATE COMPETENCY LEVELS ==========
if (assessment.IsPassed == true)
{
    // Find competencies mapped to this assessment's category
    var mappedCompetencies = await _context.AssessmentCompetencyMaps
        .Include(m => m.KkjMatrixItem)
        .Where(m => m.AssessmentCategory == assessment.Category &&
                    (m.TitlePattern == null || assessment.Title.Contains(m.TitlePattern)))
        .ToListAsync();

    if (mappedCompetencies.Any())
    {
        // Get user's position for target level resolution
        var assessmentUser = await _context.Users.FindAsync(assessment.UserId);

        foreach (var mapping in mappedCompetencies)
        {
            // Check minimum score if specified, otherwise use pass status
            if (mapping.MinimumScoreRequired.HasValue && assessment.Score < mapping.MinimumScoreRequired.Value)
                continue;

            // Check if user already has a level for this competency
            var existingLevel = await _context.UserCompetencyLevels
                .FirstOrDefaultAsync(c => c.UserId == assessment.UserId &&
                                         c.KkjMatrixItemId == mapping.KkjMatrixItemId);

            if (existingLevel == null)
            {
                // Create new competency level record
                int targetLevel = PositionTargetHelper.GetTargetLevel(mapping.KkjMatrixItem!, assessmentUser?.Position);
                _context.UserCompetencyLevels.Add(new UserCompetencyLevel
                {
                    UserId = assessment.UserId,
                    KkjMatrixItemId = mapping.KkjMatrixItemId,
                    CurrentLevel = mapping.LevelGranted,
                    TargetLevel = targetLevel,
                    Source = "Assessment",
                    AssessmentSessionId = assessment.Id,
                    AchievedAt = DateTime.UtcNow
                });
            }
            else if (mapping.LevelGranted > existingLevel.CurrentLevel)
            {
                // Only upgrade, never downgrade (monotonic progression)
                existingLevel.CurrentLevel = mapping.LevelGranted;
                existingLevel.Source = "Assessment";
                existingLevel.AssessmentSessionId = assessment.Id;
                existingLevel.UpdatedAt = DateTime.UtcNow;
            }
        }
    }
}
```

Key design decisions:
- Monotonic progression: only increase levels, never decrease
- TitlePattern uses Contains() for matching (not regex, to keep it simple)
- MinimumScoreRequired is optional; if null, passing the assessment is sufficient
- TargetLevel is denormalized at creation time using PositionTargetHelper
- The existing `await _context.SaveChangesAsync()` call after the Update handles all changes in one transaction
  </action>
  <verify>
    `dotnet build` succeeds. Read the SubmitExam method to confirm the auto-update block exists after IsPassed calculation and before SaveChangesAsync.
  </verify>
  <done>
    SubmitExam action queries AssessmentCompetencyMaps when assessment is passed, creates or updates UserCompetencyLevel records with monotonic progression, and saves in same transaction as assessment completion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create assessment-competency seed data</name>
  <files>
    Data/SeedCompetencyMappings.cs
    Program.cs
  </files>
  <action>
**1. Create Data/SeedCompetencyMappings.cs:**

Create a static seeder class that populates AssessmentCompetencyMap with initial mappings between assessment categories and KKJ competencies.

```csharp
using HcPortal.Models.Competency;
using Microsoft.EntityFrameworkCore;

namespace HcPortal.Data;

public static class SeedCompetencyMappings
{
    public static async Task SeedAsync(ApplicationDbContext context)
    {
        // Skip if already seeded
        if (await context.AssessmentCompetencyMaps.AnyAsync())
            return;

        // Load all KKJ matrix items to reference by Kompetensi name
        var kkjItems = await context.KkjMatrices.ToListAsync();

        if (!kkjItems.Any()) return; // No KKJ data to map to

        var mappings = new List<AssessmentCompetencyMap>();

        // Map assessment categories to relevant KKJ competency groups
        // Strategy: Use SkillGroup to broadly map categories
        // "Assessment OJ" -> Maps to OJ-related competencies (On-the-Job)
        // "IHT" -> Maps to In-House Training competencies
        // "Licencor" -> Maps to licensing/certification competencies
        // "OTS" -> Maps to Operator Training Simulator competencies
        // "Mandatory HSSE Training" -> Maps to HSSE competencies

        // Group KKJ items by SkillGroup for mapping
        var skillGroups = kkjItems.GroupBy(k => k.SkillGroup).ToDictionary(g => g.Key, g => g.ToList());

        // Assessment OJ -> Technical/operational competencies (Level 1-2)
        foreach (var item in kkjItems.Where(k =>
            k.SkillGroup.Contains("Teknis", StringComparison.OrdinalIgnoreCase) ||
            k.SkillGroup.Contains("Operasi", StringComparison.OrdinalIgnoreCase) ||
            k.SkillGroup.Contains("Operation", StringComparison.OrdinalIgnoreCase)))
        {
            mappings.Add(new AssessmentCompetencyMap
            {
                KkjMatrixItemId = item.Id,
                AssessmentCategory = "Assessment OJ",
                TitlePattern = null, // Broad mapping
                LevelGranted = 2,
                MinimumScoreRequired = null // Use assessment PassPercentage
            });
        }

        // IHT -> Knowledge-based competencies (Level 1)
        foreach (var item in kkjItems.Take(10)) // Map to first 10 core competencies
        {
            mappings.Add(new AssessmentCompetencyMap
            {
                KkjMatrixItemId = item.Id,
                AssessmentCategory = "IHT",
                TitlePattern = null,
                LevelGranted = 1,
                MinimumScoreRequired = null
            });
        }

        // Licencor -> Higher-level certifications (Level 3)
        foreach (var item in kkjItems.Where(k =>
            k.SkillGroup.Contains("Teknis", StringComparison.OrdinalIgnoreCase) ||
            k.SkillGroup.Contains("Operasi", StringComparison.OrdinalIgnoreCase) ||
            k.SkillGroup.Contains("Operation", StringComparison.OrdinalIgnoreCase)))
        {
            mappings.Add(new AssessmentCompetencyMap
            {
                KkjMatrixItemId = item.Id,
                AssessmentCategory = "Licencor",
                TitlePattern = null,
                LevelGranted = 3,
                MinimumScoreRequired = 80 // Higher bar for licensing
            });
        }

        // HSSE Training -> Safety/HSE competencies (Level 1)
        foreach (var item in kkjItems.Where(k =>
            k.Kompetensi.Contains("HSE", StringComparison.OrdinalIgnoreCase) ||
            k.Kompetensi.Contains("Safety", StringComparison.OrdinalIgnoreCase) ||
            k.Kompetensi.Contains("Keselamatan", StringComparison.OrdinalIgnoreCase) ||
            k.SkillGroup.Contains("HSE", StringComparison.OrdinalIgnoreCase)))
        {
            mappings.Add(new AssessmentCompetencyMap
            {
                KkjMatrixItemId = item.Id,
                AssessmentCategory = "Mandatory HSSE Training",
                TitlePattern = null,
                LevelGranted = 1,
                MinimumScoreRequired = null
            });
        }

        if (mappings.Any())
        {
            await context.AssessmentCompetencyMaps.AddRangeAsync(mappings);
            await context.SaveChangesAsync();
        }
    }
}
```

Note: The seed data uses broad category-level mappings as a starting point. HC can refine these later. The logic maps based on SkillGroup and Kompetensi text matching to the existing KKJ data. If KKJ data has different SkillGroup names than expected, the seed will create fewer mappings (safe fallback).

**2. Update Program.cs:**

Find the section where existing seed data runs (look for KKJ/CPDP seeding calls) and add after it:

```csharp
await SeedCompetencyMappings.SeedAsync(context);
```

This should be inside the existing `using (var scope = app.Services.CreateScope())` block where other seeding happens, after the KKJ and CPDP seeding since it depends on KkjMatrices data existing first.

Add `using HcPortal.Data;` if not already present in Program.cs.
  </action>
  <verify>
    1. `dotnet build` succeeds
    2. Run the application briefly (`dotnet run`) and check console output for any seed errors
    3. Verify SeedCompetencyMappings.cs exists in Data/ directory
    4. Verify Program.cs calls SeedCompetencyMappings.SeedAsync
  </verify>
  <done>
    Seed data creates initial assessment-to-competency mappings for Assessment OJ, IHT, Licencor, and HSSE Training categories. Program.cs calls the seeder on startup. Seeder is idempotent (skips if data exists).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` compiles without errors
2. SubmitExam action has auto-update competency block that:
   a. Queries AssessmentCompetencyMaps by category
   b. Creates/updates UserCompetencyLevel records
   c. Only upgrades levels (monotonic)
3. SeedCompetencyMappings creates initial mapping data
4. Program.cs calls the seeder after KKJ data is loaded
5. The app starts and runs without errors
</verification>

<success_criteria>
- Assessment completion automatically creates/updates competency levels when mappings exist
- Competency levels never decrease on re-assessment (monotonic progression)
- Seed data provides reasonable initial mappings between categories and KKJ competencies
- Existing SubmitExam flow (score calculation, redirect to Results) is not broken
- All changes save in a single transaction for consistency
</success_criteria>

<output>
After completion, create `.planning/phases/03-kkj-cpdp-integration/03-02-SUMMARY.md`
</output>
