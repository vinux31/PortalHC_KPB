---
phase: 07-development-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Models/DevDashboardViewModel.cs
  - Controllers/CDPController.cs
autonomous: true

must_haves:
  truths:
    - "DevDashboard action returns 403 when a Coachee (RoleLevel 6) accesses it"
    - "DevDashboard action returns 200 for Coach, SrSupervisor, SectionHead, HC, and Admin roles"
    - "Coach role sees only coachees in their Unit; SrSupervisor/SectionHead see their Section; HC/Admin see all"
    - "ViewModel contains per-coachee progress rows with deliverable counts (Total, Approved, Submitted, Rejected, Active)"
    - "ViewModel contains TrendLabels and TrendValues derived from ProtonFinalAssessment.CompletedAt grouped by month"
    - "ViewModel contains StatusLabels and StatusData for deliverable status distribution doughnut chart"
    - "ScopeLabel correctly reflects scope: 'Unit: <value>', 'Section: <value>', or 'All Sections'"
  artifacts:
    - path: "Models/DevDashboardViewModel.cs"
      provides: "DevDashboardViewModel and CoacheeProgressRow classes"
      contains: "class DevDashboardViewModel"
    - path: "Controllers/CDPController.cs"
      provides: "DevDashboard GET action"
      contains: "DevDashboard"
  key_links:
    - from: "Controllers/CDPController.cs DevDashboard"
      to: "Models/DevDashboardViewModel.cs"
      via: "new DevDashboardViewModel { ... }"
      pattern: "new DevDashboardViewModel"
    - from: "CDPController.DevDashboard"
      to: "_context.ProtonDeliverableProgresses"
      via: "GroupBy(p => p.CoacheeId).Select()"
      pattern: "GroupBy.*CoacheeId"
    - from: "CDPController.DevDashboard"
      to: "_context.ProtonFinalAssessments"
      via: "GroupBy year-month for trend chart"
      pattern: "ProtonFinalAssessments.*GroupBy"
---

<objective>
Create the DevDashboardViewModel and CDPController.DevDashboard GET action with role-scoped data loading, per-coachee progress aggregation, and chart data preparation.

Purpose: Backend foundation for the development dashboard — scopes coachee data by role, computes deliverable statistics, and prepares Chart.js-ready data arrays for the view.
Output: DevDashboardViewModel.cs (new), CDPController.DevDashboard GET action (added to existing controller)
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-development-dashboard/07-RESEARCH.md
@Controllers/CDPController.cs
@Models/UserRoles.cs
@Models/ProtonViewModels.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DevDashboardViewModel</name>
  <files>Models/DevDashboardViewModel.cs</files>
  <action>
Create new file `Models/DevDashboardViewModel.cs` with two classes in namespace `HcPortal.Models`:

```csharp
namespace HcPortal.Models;

public class DevDashboardViewModel
{
    // Summary cards
    public int TotalCoachees { get; set; }
    public int TotalDeliverables { get; set; }
    public int ApprovedDeliverables { get; set; }
    public int PendingSpvApprovals { get; set; }    // Status == "Submitted"
    public int PendingHCReviews { get; set; }       // HCApprovalStatus == "Pending" && Status == "Approved"
    public int CompletedCoachees { get; set; }      // coachees with a ProtonFinalAssessment

    // Per-coachee rows
    public List<CoacheeProgressRow> CoacheeRows { get; set; } = new();

    // Chart: competency level granted trend (line chart)
    public List<string> TrendLabels { get; set; } = new();   // e.g. ["2025-10", "2025-11"]
    public List<double> TrendValues { get; set; } = new();   // avg CompetencyLevelGranted per month

    // Chart: deliverable status distribution (doughnut)
    // Labels: ["Approved", "Submitted", "Active", "Rejected", "Locked"]
    public List<string> StatusLabels { get; set; } = new();
    public List<int> StatusData { get; set; } = new();

    // Context display
    public string CurrentUserRole { get; set; } = "";
    public string ScopeLabel { get; set; } = "";   // "Unit: RFCC NHT" / "Section: GAST" / "All Sections"
}

public class CoacheeProgressRow
{
    public string CoacheeId { get; set; } = "";
    public string CoacheeName { get; set; } = "";
    public string TrackType { get; set; } = "";     // "Operator" or "Panelman"; "" if not assigned
    public string TahunKe { get; set; } = "";       // "Tahun 1" / "Tahun 2" / "Tahun 3"; "" if not assigned
    public int TotalDeliverables { get; set; }
    public int Approved { get; set; }
    public int Submitted { get; set; }
    public int Rejected { get; set; }
    public int Active { get; set; }
    public int Locked { get; set; }
    public bool HasFinalAssessment { get; set; }
    public int? CompetencyLevelGranted { get; set; }

    public string ProgressPercent => TotalDeliverables > 0
        ? $"{(int)((double)Approved / TotalDeliverables * 100)}%"
        : "0%";
}
```
  </action>
  <verify>Project builds without error: `dotnet build` from project root exits 0.</verify>
  <done>DevDashboardViewModel.cs exists in Models/; both classes compile; no build errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add CDPController.DevDashboard GET action</name>
  <files>Controllers/CDPController.cs</files>
  <action>
Add the `DevDashboard` GET action to `CDPController` immediately after the existing `Dashboard()` action (around line 230). The action follows these exact steps:

**Step 1 — Auth and access guard:**
```csharp
public async Task<IActionResult> DevDashboard()
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null) return Challenge();

    var roles = await _userManager.GetRolesAsync(user);
    var userRole = roles.FirstOrDefault() ?? "";

    // DASH-01: Coachees (RoleLevel 6) have no access
    if (user.RoleLevel >= 6 && userRole != UserRoles.Admin && userRole != UserRoles.HC)
        return Forbid();
```

**Step 2 — Build scoped coachee ID list (DASH-02):**
```csharp
    List<string> scopedCoacheeIds;
    string scopeLabel;

    if (userRole == UserRoles.HC || userRole == UserRoles.Admin)
    {
        scopedCoacheeIds = await _context.Users
            .Where(u => u.RoleLevel == 6)
            .Select(u => u.Id)
            .ToListAsync();
        scopeLabel = "All Sections";
    }
    else if (userRole == UserRoles.SrSupervisor || userRole == UserRoles.SectionHead)
    {
        scopedCoacheeIds = await _context.Users
            .Where(u => u.Section == user.Section && u.RoleLevel == 6)
            .Select(u => u.Id)
            .ToListAsync();
        scopeLabel = $"Section: {user.Section ?? "(unknown)"}";
    }
    else // UserRoles.Coach (Spv)
    {
        // Null-guard: fall back to Section if Unit is unset
        if (!string.IsNullOrEmpty(user.Unit))
        {
            scopedCoacheeIds = await _context.Users
                .Where(u => u.Unit == user.Unit && u.RoleLevel == 6)
                .Select(u => u.Id)
                .ToListAsync();
            scopeLabel = $"Unit: {user.Unit}";
        }
        else
        {
            scopedCoacheeIds = await _context.Users
                .Where(u => u.Section == user.Section && u.RoleLevel == 6)
                .Select(u => u.Id)
                .ToListAsync();
            scopeLabel = $"Section: {user.Section ?? "(unknown)"} (Unit not set)";
        }
    }
```

**Step 3 — Batch load data (avoid N+1):**
```csharp
    // Batch user names
    var coacheeUsers = await _context.Users
        .Where(u => scopedCoacheeIds.Contains(u.Id))
        .ToListAsync();
    var userNames = coacheeUsers.ToDictionary(u => u.Id, u => u.FullName ?? u.UserName ?? u.Id);

    // All progress records for scoped coachees in one query
    var allProgresses = await _context.ProtonDeliverableProgresses
        .Where(p => scopedCoacheeIds.Contains(p.CoacheeId))
        .ToListAsync();

    // Track assignments for track type / tahun display
    var assignments = await _context.ProtonTrackAssignments
        .Where(a => scopedCoacheeIds.Contains(a.CoacheeId) && a.IsActive)
        .ToListAsync();
    var assignmentDict = assignments.ToDictionary(a => a.CoacheeId, a => a);

    // Final assessments for completion flag and CompetencyLevelGranted
    var finalAssessments = await _context.ProtonFinalAssessments
        .Where(fa => scopedCoacheeIds.Contains(fa.CoacheeId))
        .ToListAsync();
    var finalAssessmentDict = finalAssessments
        .GroupBy(fa => fa.CoacheeId)
        .ToDictionary(g => g.Key, g => g.OrderByDescending(fa => fa.CreatedAt).First());
```

**Step 4 — Build per-coachee rows:**
```csharp
    var progressByCoachee = allProgresses.GroupBy(p => p.CoacheeId)
        .ToDictionary(g => g.Key, g => g.ToList());

    var coacheeRows = new List<CoacheeProgressRow>();
    foreach (var coacheeId in scopedCoacheeIds)
    {
        var progresses = progressByCoachee.GetValueOrDefault(coacheeId) ?? new List<ProtonDeliverableProgress>();
        var assignment = assignmentDict.GetValueOrDefault(coacheeId);
        finalAssessmentDict.TryGetValue(coacheeId, out var finalAssessment);

        coacheeRows.Add(new CoacheeProgressRow
        {
            CoacheeId = coacheeId,
            CoacheeName = userNames.GetValueOrDefault(coacheeId, coacheeId),
            TrackType = assignment?.TrackType ?? "",
            TahunKe = assignment?.TahunKe ?? "",
            TotalDeliverables = progresses.Count,
            Approved = progresses.Count(p => p.Status == "Approved"),
            Submitted = progresses.Count(p => p.Status == "Submitted"),
            Rejected = progresses.Count(p => p.Status == "Rejected"),
            Active = progresses.Count(p => p.Status == "Active"),
            Locked = progresses.Count(p => p.Status == "Locked"),
            HasFinalAssessment = finalAssessment != null,
            CompetencyLevelGranted = finalAssessment?.CompetencyLevelGranted
        });
    }
    coacheeRows = coacheeRows.OrderBy(r => r.CoacheeName).ToList();
```

**Step 5 — Summary card totals:**
```csharp
    int pendingSpv = allProgresses.Count(p => p.Status == "Submitted");
    int pendingHC  = allProgresses.Count(p => p.HCApprovalStatus == "Pending" && p.Status == "Approved");
```

**Step 6 — Chart data (DASH-04): competency trend from ProtonFinalAssessments grouped by month:**
```csharp
    var scopedCompletedAssessments = finalAssessments
        .Where(fa => fa.CompletedAt.HasValue)
        .OrderBy(fa => fa.CompletedAt)
        .ToList();

    List<string> trendLabels = new();
    List<double> trendValues = new();

    if (scopedCompletedAssessments.Any())
    {
        var grouped = scopedCompletedAssessments
            .GroupBy(fa => new { fa.CompletedAt!.Value.Year, fa.CompletedAt!.Value.Month })
            .OrderBy(g => g.Key.Year).ThenBy(g => g.Key.Month);

        foreach (var g in grouped)
        {
            trendLabels.Add($"{g.Key.Year}-{g.Key.Month:D2}");
            trendValues.Add(Math.Round(g.Average(fa => (double)fa.CompetencyLevelGranted), 2));
        }
    }

    // Doughnut chart: status distribution
    var statusLabels = new List<string> { "Approved", "Submitted", "Active", "Rejected", "Locked" };
    var statusData = new List<int>
    {
        allProgresses.Count(p => p.Status == "Approved"),
        allProgresses.Count(p => p.Status == "Submitted"),
        allProgresses.Count(p => p.Status == "Active"),
        allProgresses.Count(p => p.Status == "Rejected"),
        allProgresses.Count(p => p.Status == "Locked")
    };
```

**Step 7 — Build and return ViewModel:**
```csharp
    var viewModel = new DevDashboardViewModel
    {
        TotalCoachees = scopedCoacheeIds.Count,
        TotalDeliverables = allProgresses.Count,
        ApprovedDeliverables = allProgresses.Count(p => p.Status == "Approved"),
        PendingSpvApprovals = pendingSpv,
        PendingHCReviews = pendingHC,
        CompletedCoachees = finalAssessmentDict.Count,
        CoacheeRows = coacheeRows,
        TrendLabels = trendLabels,
        TrendValues = trendValues,
        StatusLabels = statusLabels,
        StatusData = statusData,
        CurrentUserRole = userRole,
        ScopeLabel = scopeLabel
    };

    return View(viewModel);
}
```

Add the required using at the top of CDPController.cs if not present: `using HcPortal.Models;` (already present — do not duplicate).

Do NOT modify the existing `Dashboard()` action. This is a new separate action.
  </action>
  <verify>
1. `dotnet build` exits 0 with no errors or warnings about DevDashboard.
2. `grep -n "DevDashboard" Controllers/CDPController.cs` shows the new action.
3. Confirm the existing `Dashboard()` action is unchanged by checking it still starts at the same line.
  </verify>
  <done>
CDPController.cs has a new `DevDashboard()` GET action. The action: returns Forbid for Coachee role; scopes coachee IDs by role (Unit for Coach, Section for SrSpv/SectionHead, all for HC/Admin); uses batch queries (no N+1); returns a populated DevDashboardViewModel with per-coachee rows, trend chart data, and doughnut data. Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds with no errors
- `Models/DevDashboardViewModel.cs` exists with `DevDashboardViewModel` and `CoacheeProgressRow` classes
- `Controllers/CDPController.cs` contains `DevDashboard()` action
- Action has `return Forbid()` for Coachee role
- Action has three branches for role scoping (HC/Admin, SrSpv/SectionHead, Coach)
- No modifications to the existing `Dashboard()` action
</verification>

<success_criteria>
DevDashboardViewModel compiles. CDPController.DevDashboard GET action is reachable, returns Forbid for Coachee, returns a populated DevDashboardViewModel (even if view doesn't exist yet — will return 500 on view resolution, not on the action logic). Build exits 0.
</success_criteria>

<output>
After completion, create `.planning/phases/07-development-dashboard/07-01-SUMMARY.md` following the summary template.
</output>
