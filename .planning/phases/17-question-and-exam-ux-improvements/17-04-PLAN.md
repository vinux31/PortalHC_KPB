---
phase: 17-question-and-exam-ux-improvements
plan: "04"
type: execute
wave: 4
depends_on: ["17-03"]
files_modified:
  - Controllers/CMPController.cs
  - Models/PackageExamViewModel.cs
autonomous: true

must_haves:
  truths:
    - "When a user starts an exam, the system auto-assigns them one of the assessment's packages (random if multiple exist, any if only one)"
    - "Each user's assigned package and shuffled question/option order is persisted in UserPackageAssignment before the exam page loads"
    - "If the user's package assignment already exists (resuming), the existing shuffled order is used — not re-randomized"
    - "If the assessment has no packages, the legacy question path is used as fallback"
  artifacts:
    - path: "Models/PackageExamViewModel.cs"
      provides: "ViewModel with per-user ordered questions and options for the paged exam view"
      contains: "class PackageExamViewModel"
    - path: "Controllers/CMPController.cs"
      provides: "Extended StartExam GET with package assignment and randomization logic"
      contains: "UserPackageAssignment"
  key_links:
    - from: "Controllers/CMPController.cs StartExam GET"
      to: "Models/PackageExamViewModel.cs"
      via: "return View(packageExamViewModel)"
      pattern: "PackageExamViewModel"
    - from: "Controllers/CMPController.cs StartExam GET"
      to: "Data/ApplicationDbContext.cs UserPackageAssignments"
      via: "context.UserPackageAssignments.Add or FirstOrDefault"
      pattern: "UserPackageAssignments"
---

<objective>
Implement per-user package assignment and question/option randomization. Extends StartExam GET to assign a random package and persist the shuffled order before rendering the exam.

Purpose: ID-based grading requires the per-user shuffle to be stored — the exam view reads from this record so grading is always based on stable IDs, never displayed letters.
Output: PackageExamViewModel, extended StartExam GET action with full randomization + assignment persistence.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@Controllers/CMPController.cs
@Models/AssessmentSession.cs
@Models/AssessmentPackage.cs
@Models/UserPackageAssignment.cs
@Data/ApplicationDbContext.cs
@.planning/phases/17-question-and-exam-ux-improvements/17-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PackageExamViewModel</name>
  <files>Models/PackageExamViewModel.cs</files>
  <action>
Create `Models/PackageExamViewModel.cs`. This is the data shape passed from StartExam GET to StartExam.cshtml.

```csharp
namespace HcPortal.Models
{
    /// <summary>
    /// Carries per-user shuffled exam data from StartExam GET to the exam view.
    /// Question and option order reflects the user's individual randomization.
    /// </summary>
    public class PackageExamViewModel
    {
        // Assessment identity
        public int AssessmentSessionId { get; set; }
        public string Title { get; set; } = "";
        public int DurationMinutes { get; set; }

        // Package info
        public bool HasPackages { get; set; }      // false = legacy path (no packages)
        public int? AssignmentId { get; set; }     // UserPackageAssignment.Id (for package path)

        // Ordered list of questions in this user's shuffled sequence
        public List<ExamQuestionItem> Questions { get; set; } = new();

        // Total count (for header display: "7/30 answered")
        public int TotalQuestions => Questions.Count;
    }

    public class ExamQuestionItem
    {
        public int QuestionId { get; set; }         // PackageQuestion.Id or AssessmentQuestion.Id
        public string QuestionText { get; set; } = "";
        public int DisplayNumber { get; set; }      // 1-based, user-facing number (reflects shuffled position)
        public List<ExamOptionItem> Options { get; set; } = new();
    }

    public class ExamOptionItem
    {
        public int OptionId { get; set; }           // PackageOption.Id or AssessmentOption.Id
        public string OptionText { get; set; } = "";
        // Display letter (A/B/C/D) is assigned at render time by position index, NOT stored here
    }
}
```
  </action>
  <verify>`dotnet build` exits 0.</verify>
  <done>Models/PackageExamViewModel.cs exists with all three classes; project builds.</done>
</task>

<task type="auto">
  <name>Task 2: Extend StartExam GET with package assignment + randomization</name>
  <files>Controllers/CMPController.cs</files>
  <action>
Replace the existing `StartExam GET` action. The new action has two branches:

**Branch A — Package path (assessment has packages):**
1. Load assessment with navigation (no need to load old Questions/Options in this path)
2. Check if `UserPackageAssignment` already exists for this `AssessmentSessionId`
3. If not: randomly select a package → shuffle question IDs → shuffle option IDs per question → persist `UserPackageAssignment`
4. Load questions and options in the stored shuffled order → build `PackageExamViewModel`

**Branch B — Legacy path (no packages):**
- Fallback to old behavior (load `assessment.Questions` in Order, no shuffle) → build `PackageExamViewModel` with `HasPackages = false`

Replace the current `StartExam` GET:

```csharp
[HttpGet]
public async Task<IActionResult> StartExam(int id)
{
    var assessment = await _context.AssessmentSessions
        .FirstOrDefaultAsync(a => a.Id == id);

    if (assessment == null) return NotFound();

    var user = await _userManager.GetUserAsync(User);
    if (user == null) return Challenge();
    if (assessment.UserId != user.Id && !User.IsInRole("Admin") && !User.IsInRole("HC"))
        return Forbid();

    if (assessment.Status == "Completed")
    {
        TempData["Error"] = "This assessment has already been completed.";
        return RedirectToAction("Assessment");
    }

    // Check if this assessment has packages
    var packages = await _context.AssessmentPackages
        .Include(p => p.Questions)
            .ThenInclude(q => q.Options)
        .Where(p => p.AssessmentSessionId == id)
        .OrderBy(p => p.PackageNumber)
        .ToListAsync();

    PackageExamViewModel vm;

    if (packages.Any())
    {
        // ---- PACKAGE PATH ----

        // Check for existing assignment (idempotent — resume)
        var assignment = await _context.UserPackageAssignments
            .FirstOrDefaultAsync(a => a.AssessmentSessionId == id);

        if (assignment == null)
        {
            // Randomly assign a package
            var rng = new Random();
            var selectedPackage = packages[rng.Next(packages.Count)];

            // Shuffle question order
            var questionIds = selectedPackage.Questions
                .OrderBy(q => q.Order)
                .Select(q => q.Id)
                .ToList();
            Shuffle(questionIds, rng);

            // Shuffle options per question
            var optionOrderDict = new Dictionary<int, List<int>>();
            foreach (var q in selectedPackage.Questions)
            {
                var optIds = q.Options.Select(o => o.Id).ToList();
                Shuffle(optIds, rng);
                optionOrderDict[q.Id] = optIds;
            }

            assignment = new UserPackageAssignment
            {
                AssessmentSessionId = id,
                AssessmentPackageId = selectedPackage.Id,
                UserId = user.Id,
                ShuffledQuestionIds = System.Text.Json.JsonSerializer.Serialize(questionIds),
                ShuffledOptionIdsPerQuestion = System.Text.Json.JsonSerializer.Serialize(
                    optionOrderDict.ToDictionary(kv => kv.Key.ToString(), kv => kv.Value))
            };
            _context.UserPackageAssignments.Add(assignment);
            await _context.SaveChangesAsync();
        }

        // Load the assigned package
        var assignedPackage = packages.First(p => p.Id == assignment.AssessmentPackageId);

        // Build ViewModel in shuffled order
        var shuffledQuestionIds = assignment.GetShuffledQuestionIds();
        var shuffledOptionIds = assignment.GetShuffledOptionIds();

        var questionLookup = assignedPackage.Questions.ToDictionary(q => q.Id);
        var optionLookup = assignedPackage.Questions
            .SelectMany(q => q.Options)
            .ToDictionary(o => o.Id);

        var examQuestions = new List<ExamQuestionItem>();
        int displayNum = 1;
        foreach (var qId in shuffledQuestionIds)
        {
            if (!questionLookup.TryGetValue(qId, out var q)) continue;

            var orderedOptIds = shuffledOptionIds.TryGetValue(qId, out var optIds)
                ? optIds
                : q.Options.Select(o => o.Id).ToList();

            var opts = orderedOptIds
                .Where(oid => optionLookup.ContainsKey(oid))
                .Select(oid => new ExamOptionItem
                {
                    OptionId = optionLookup[oid].Id,
                    OptionText = optionLookup[oid].OptionText
                }).ToList();

            examQuestions.Add(new ExamQuestionItem
            {
                QuestionId = q.Id,
                QuestionText = q.QuestionText,
                DisplayNumber = displayNum++,
                Options = opts
            });
        }

        vm = new PackageExamViewModel
        {
            AssessmentSessionId = id,
            Title = assessment.Title,
            DurationMinutes = assessment.DurationMinutes,
            HasPackages = true,
            AssignmentId = assignment.Id,
            Questions = examQuestions
        };
    }
    else
    {
        // ---- LEGACY PATH: no packages, use old AssessmentQuestion/Option ----
        var assessmentWithQuestions = await _context.AssessmentSessions
            .Include(a => a.Questions)
                .ThenInclude(q => q.Options)
            .FirstOrDefaultAsync(a => a.Id == id);

        var legacyQuestions = assessmentWithQuestions?.Questions
            .OrderBy(q => q.Order)
            .Select((q, i) => new ExamQuestionItem
            {
                QuestionId = q.Id,
                QuestionText = q.QuestionText,
                DisplayNumber = i + 1,
                Options = q.Options.Select(o => new ExamOptionItem
                {
                    OptionId = o.Id,
                    OptionText = o.OptionText
                }).ToList()
            }).ToList() ?? new List<ExamQuestionItem>();

        vm = new PackageExamViewModel
        {
            AssessmentSessionId = id,
            Title = assessment.Title,
            DurationMinutes = assessment.DurationMinutes,
            HasPackages = false,
            AssignmentId = null,
            Questions = legacyQuestions
        };
    }

    return View(vm);
}

// Helper: Fisher-Yates shuffle
private static void Shuffle<T>(List<T> list, Random rng)
{
    for (int i = list.Count - 1; i > 0; i--)
    {
        int j = rng.Next(i + 1);
        (list[i], list[j]) = (list[j], list[i]);
    }
}
```

Add `using System.Text.Json;` at top if not already present.

NOTE: The old `#region Question Management` `StartExam` references `AssessmentSession` with `Include(a => a.Questions)`. The new version queries packages first, and only loads `AssessmentSessions` with Questions for the legacy fallback. This is intentional — the new path uses `AssessmentPackages` not `AssessmentQuestions`.
  </action>
  <verify>
1. `dotnet build` exits 0
2. StartExam GET returns a `PackageExamViewModel` to the view (old `AssessmentSession` model no longer bound to this view)
  </verify>
  <done>
StartExam GET replaced with package-aware logic. Fisher-Yates shuffle helper added. Package assignment persisted on first visit. Legacy fallback for assessments without packages. Project builds.
  </done>
</task>

</tasks>

<verification>
`dotnet build` exits 0. StartExam GET for an assessment with packages creates a `UserPackageAssignment` row on first load. Re-loading the exam does NOT create a new assignment. Assessments without packages still reach the exam page using legacy question data.
</verification>

<success_criteria>
- PackageExamViewModel + ExamQuestionItem + ExamOptionItem classes exist
- StartExam GET assigns package randomly on first visit, reuses existing on resume
- Shuffled order persisted in UserPackageAssignment as JSON
- Legacy path (no packages) still functional
- Fisher-Yates shuffle helper added
- Project builds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-question-and-exam-ux-improvements/17-04-SUMMARY.md`
</output>
