---
phase: 17-question-and-exam-ux-improvements
plan: "06"
type: execute
wave: 6
depends_on: ["17-05"]
files_modified:
  - Controllers/CMPController.cs
  - Views/CMP/ExamSummary.cshtml
autonomous: true

must_haves:
  truths:
    - "After the last exam page, user sees a summary page showing all questions and their selected answers before submitting"
    - "If the user has unanswered questions, a warning shows the count ('You have X unanswered questions') but does not block submission"
    - "Final Submit button on the summary page submits the exam; post-submit redirects to the existing Results page"
    - "Grading uses PackageOption.Id (not displayed letters) — correct answer identified by PackageOption.IsCorrect on the stored answer key"
    - "Legacy assessments (no packages) still grade correctly via the existing AssessmentOption.IsCorrect path"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "ExamSummary POST action (stores answers in TempData, redirects to GET); ExamSummary GET (loads summary); SubmitExam POST updated for package path ID-based grading"
      contains: "ExamSummary"
    - path: "Views/CMP/ExamSummary.cshtml"
      provides: "Summary page listing all questions with user's answers, unanswered warning, final Submit button"
      contains: "ExamSummary"
  key_links:
    - from: "Views/CMP/StartExam.cshtml"
      to: "Controllers/CMPController.cs ExamSummary POST"
      via: "form asp-action=ExamSummary with answers dictionary"
      pattern: "ExamSummary"
    - from: "Views/CMP/ExamSummary.cshtml"
      to: "Controllers/CMPController.cs SubmitExam POST"
      via: "final submit form posts to SubmitExam"
      pattern: "SubmitExam"
    - from: "Controllers/CMPController.cs SubmitExam POST"
      to: "Data/ApplicationDbContext.cs PackageOptions"
      via: "IsCorrect lookup on PackageOption for ID-based grading"
      pattern: "PackageOptions.*IsCorrect"
---

<objective>
Build the pre-submit review flow: ExamSummary page shows all answers before final submission; update SubmitExam to grade via PackageOption.Id for the package path.

Purpose: User reviews their answers before committing. Grading must use stable option IDs (not displayed letters) since options are shuffled per user.
Output: ExamSummary POST + GET actions, ExamSummary.cshtml view, updated SubmitExam POST with package-aware ID-based grading.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@Controllers/CMPController.cs
@Models/PackageExamViewModel.cs
@Models/AssessmentPackage.cs
@Models/UserPackageAssignment.cs
@Models/AssessmentResultsViewModel.cs
@.planning/phases/17-question-and-exam-ux-improvements/17-04-SUMMARY.md
@.planning/phases/17-question-and-exam-ux-improvements/17-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ExamSummary POST, ExamSummary GET, and update SubmitExam POST</name>
  <files>Controllers/CMPController.cs</files>
  <action>
**Part A — ExamSummary POST (receives answers from StartExam form, stores in TempData, redirects to GET):**

```csharp
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> ExamSummary(int id, int? assignmentId, Dictionary<int, int> answers)
{
    // Validate ownership
    var user = await _userManager.GetUserAsync(User);
    if (user == null) return Challenge();

    var assessment = await _context.AssessmentSessions.FindAsync(id);
    if (assessment == null) return NotFound();
    if (assessment.UserId != user.Id && !User.IsInRole("Admin") && !User.IsInRole("HC"))
        return Forbid();
    if (assessment.Status == "Completed")
    {
        TempData["Error"] = "This assessment has already been completed.";
        return RedirectToAction("Assessment");
    }

    // Store answers in TempData (dictionary key=questionId, value=selectedOptionId)
    TempData["PendingAnswers"] = System.Text.Json.JsonSerializer.Serialize(answers);
    TempData["PendingAssessmentId"] = id;
    TempData["PendingAssignmentId"] = assignmentId;

    return RedirectToAction("ExamSummary", new { id });
}
```

**Part B — ExamSummary GET (builds summary ViewModel from TempData + DB):**

```csharp
[HttpGet]
public async Task<IActionResult> ExamSummary(int id)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null) return Challenge();

    var assessment = await _context.AssessmentSessions.FindAsync(id);
    if (assessment == null) return NotFound();
    if (assessment.UserId != user.Id && !User.IsInRole("Admin") && !User.IsInRole("HC"))
        return Forbid();

    // Retrieve pending answers from TempData
    var answersJson = TempData["PendingAnswers"] as string ?? "{}";
    var answers = System.Text.Json.JsonSerializer.Deserialize<Dictionary<int, int>>(answersJson)
                  ?? new Dictionary<int, int>();

    // Preserve for the final submit form
    TempData.Keep("PendingAnswers");
    TempData.Keep("PendingAssessmentId");
    TempData.Keep("PendingAssignmentId");

    // CookieTempDataProvider serializes through JSON, which deserializes integers as long — handle both int and long
    int? assignmentId = TempData["PendingAssignmentId"] switch {
        int i => i,
        long l => (int)l,
        _ => (int?)null
    };

    // Build summary items
    var summaryItems = new List<ExamSummaryItem>();

    // Check for package path
    var assignment = assignmentId.HasValue
        ? await _context.UserPackageAssignments.FindAsync(assignmentId.Value)
        : null;

    if (assignment != null)
    {
        var shuffledQIds = assignment.GetShuffledQuestionIds();
        var questions = await _context.PackageQuestions
            .Include(q => q.Options)
            .Where(q => q.AssessmentPackageId == assignment.AssessmentPackageId)
            .ToListAsync();

        var qLookup = questions.ToDictionary(q => q.Id);
        var optLookup = questions.SelectMany(q => q.Options).ToDictionary(o => o.Id);

        int num = 1;
        foreach (var qId in shuffledQIds)
        {
            if (!qLookup.TryGetValue(qId, out var q)) continue;
            int? selectedOptId = answers.TryGetValue(qId, out var v) ? v : (int?)null;
            string? selectedText = selectedOptId.HasValue && optLookup.TryGetValue(selectedOptId.Value, out var opt)
                ? opt.OptionText
                : null;

            summaryItems.Add(new ExamSummaryItem
            {
                DisplayNumber = num++,
                QuestionId = qId,
                QuestionText = q.QuestionText,
                SelectedOptionId = selectedOptId,
                SelectedOptionText = selectedText
            });
        }
    }
    else
    {
        // Legacy path: AssessmentQuestion
        var legacyQuestions = await _context.AssessmentQuestions
            .Include(q => q.Options)
            .Where(q => q.AssessmentSessionId == id)
            .OrderBy(q => q.Order)
            .ToListAsync();

        var optLookup = legacyQuestions.SelectMany(q => q.Options).ToDictionary(o => o.Id);

        int num = 1;
        foreach (var q in legacyQuestions)
        {
            int? selectedOptId = answers.TryGetValue(q.Id, out var v) ? v : (int?)null;
            string? selectedText = selectedOptId.HasValue && optLookup.TryGetValue(selectedOptId.Value, out var opt)
                ? opt.OptionText
                : null;

            summaryItems.Add(new ExamSummaryItem
            {
                DisplayNumber = num++,
                QuestionId = q.Id,
                QuestionText = q.QuestionText,
                SelectedOptionId = selectedOptId,
                SelectedOptionText = selectedText
            });
        }
    }

    int unansweredCount = summaryItems.Count(s => !s.SelectedOptionId.HasValue);

    ViewBag.AssessmentTitle = assessment.Title;
    ViewBag.AssessmentId = id;
    ViewBag.AssignmentId = assignmentId;
    ViewBag.UnansweredCount = unansweredCount;
    ViewBag.Answers = answers; // passed to the hidden final-submit form
    return View(summaryItems);
}
```

**Part C — Update SubmitExam POST for package-aware grading:**

The existing SubmitExam POST grades using `AssessmentQuestion` + `AssessmentOption`. Wrap the entire existing grading logic in an `else` branch so it is only reached when no package assignment exists. The full structure must be:

```csharp
// At the top of SubmitExam POST, after authorization and completion checks:
var packageAssignment = await _context.UserPackageAssignments
    .FirstOrDefaultAsync(a => a.AssessmentSessionId == id);

if (packageAssignment != null)
{
    // ---- PACKAGE PATH: ID-based grading ----
    var packageQuestions = await _context.PackageQuestions
        .Include(q => q.Options)
        .Where(q => q.AssessmentPackageId == packageAssignment.AssessmentPackageId)
        .ToListAsync();

    int totalScore = 0;
    int maxScore = packageQuestions.Count * 10; // each question = 10 points

    foreach (var q in packageQuestions)
    {
        int? selectedOptId = answers.ContainsKey(q.Id) ? answers[q.Id] : (int?)null;

        if (selectedOptId.HasValue)
        {
            var selectedOption = q.Options.FirstOrDefault(o => o.Id == selectedOptId.Value);
            if (selectedOption != null && selectedOption.IsCorrect)
                totalScore += q.ScoreValue;
        }

        // Note: UserResponse records not created for package exams — AllowAnswerReview is not supported
        // for package-based exams in this phase. UserResponse.AssessmentQuestionId and
        // UserResponse.SelectedOptionId have hard FK constraints to AssessmentQuestions and
        // AssessmentOptions tables; PackageQuestion/PackageOption IDs do not exist in those tables.
    }

    int finalPercentage = maxScore > 0 ? (int)((double)totalScore / maxScore * 100) : 0;

    assessment.Score = finalPercentage;
    assessment.Status = "Completed";
    assessment.Progress = 100;
    assessment.IsPassed = finalPercentage >= assessment.PassPercentage;
    assessment.CompletedAt = DateTime.UtcNow;

    packageAssignment.IsCompleted = true;

    // Auto-update competency levels (same logic as existing SubmitExam)
    if (assessment.IsPassed == true)
    {
        var mappedCompetencies = await _context.AssessmentCompetencyMaps
            .Include(m => m.KkjMatrixItem)
            .Where(m => m.AssessmentCategory == assessment.Category &&
                        (m.TitlePattern == null || assessment.Title.Contains(m.TitlePattern)))
            .ToListAsync();

        if (mappedCompetencies.Any())
        {
            var assessmentUser = await _context.Users.FindAsync(assessment.UserId);
            foreach (var mapping in mappedCompetencies)
            {
                if (mapping.MinimumScoreRequired.HasValue && assessment.Score < mapping.MinimumScoreRequired.Value)
                    continue;

                var existingLevel = await _context.UserCompetencyLevels
                    .FirstOrDefaultAsync(c => c.UserId == assessment.UserId &&
                                             c.KkjMatrixItemId == mapping.KkjMatrixItemId);
                if (existingLevel == null)
                {
                    int targetLevel = HcPortal.Helpers.PositionTargetHelper.GetTargetLevel(mapping.KkjMatrixItem!, assessmentUser?.Position);
                    _context.UserCompetencyLevels.Add(new HcPortal.Models.Competency.UserCompetencyLevel
                    {
                        UserId = assessment.UserId,
                        KkjMatrixItemId = mapping.KkjMatrixItemId,
                        CurrentLevel = mapping.LevelGranted,
                        TargetLevel = targetLevel,
                        Source = "Assessment",
                        AssessmentSessionId = assessment.Id,
                        AchievedAt = DateTime.UtcNow
                    });
                }
                else if (mapping.LevelGranted > existingLevel.CurrentLevel)
                {
                    existingLevel.CurrentLevel = mapping.LevelGranted;
                    existingLevel.Source = "Assessment";
                    existingLevel.AssessmentSessionId = assessment.Id;
                    existingLevel.UpdatedAt = DateTime.UtcNow;
                }
            }
        }
    }

    _context.AssessmentSessions.Update(assessment);
    await _context.SaveChangesAsync();

    return RedirectToAction("Results", new { id });
}
else
{
    // ---- LEGACY PATH: existing AssessmentQuestion + AssessmentOption grading ----
    // [entire existing grading code goes here — the foreach over assessment.Questions,
    //  UserResponse creation, scoring, competency update, SaveChangesAsync, and Results redirect]
    // Do NOT execute the legacy loop when packageAssignment != null — the else branch
    // ensures the old assessment.Questions loop only fires for non-package exams,
    // preventing incorrect UserResponse FK references on package-path exams.
}
```

**Critical:** Move ALL of the existing SubmitExam grading logic (the `foreach` over `assessment.Questions`, the `UserResponse` insertions, `assessment.Score` assignment, `SaveChangesAsync`, and `return RedirectToAction("Results")`) inside the `else { }` block. Nothing from the legacy grading path should execute when `packageAssignment != null`.

**Add ExamSummaryItem to Models:**

Add this simple class to `Models/PackageExamViewModel.cs` (alongside the existing classes):
```csharp
public class ExamSummaryItem
{
    public int DisplayNumber { get; set; }
    public int QuestionId { get; set; }
    public string QuestionText { get; set; } = "";
    public int? SelectedOptionId { get; set; }
    public string? SelectedOptionText { get; set; }
    public bool IsAnswered => SelectedOptionId.HasValue;
}
```
  </action>
  <verify>
1. `dotnet build` exits 0
2. Completing an exam with package questions: score calculated correctly (not 0%)
3. Results page shows correct score and pass/fail
  </verify>
  <done>
ExamSummary POST + GET actions added. SubmitExam POST wraps legacy grading in `else` branch — package path and legacy path are mutually exclusive. TempData unboxing uses switch pattern handling both int and long (CookieTempDataProvider JSON serialization deserializes as long). No UserResponse insertions in the package path (FK constraint incompatibility documented in comment). ExamSummaryItem class added to PackageExamViewModel.cs. Project builds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ExamSummary.cshtml view</name>
  <files>Views/CMP/ExamSummary.cshtml</files>
  <action>
Create `Views/CMP/ExamSummary.cshtml`. Model is `List<HcPortal.Models.ExamSummaryItem>`.

```html
@model List<HcPortal.Models.ExamSummaryItem>

@{
    ViewData["Title"] = "Review Your Answers";
    int unanswered = (int)ViewBag.UnansweredCount;
    int assessmentId = (int)ViewBag.AssessmentId;
    int? assignmentId = ViewBag.AssignmentId as int?;
    var answers = ViewBag.Answers as Dictionary<int, int> ?? new Dictionary<int, int>();
}

<!-- Minimal header — no sticky needed here -->
<div class="container py-4" style="max-width: 860px;">
    <div class="text-center mb-4">
        <h4 class="fw-bold">Review Your Answers</h4>
        <p class="text-muted">@ViewBag.AssessmentTitle</p>
    </div>

    @if (unanswered > 0)
    {
        <div class="alert alert-warning d-flex align-items-center mb-4">
            <i class="bi bi-exclamation-triangle-fill me-2"></i>
            You have <strong class="mx-1">@unanswered</strong> unanswered question(s). You can still submit.
        </div>
    }
    else
    {
        <div class="alert alert-success d-flex align-items-center mb-4">
            <i class="bi bi-check-circle-fill me-2"></i>
            All @Model.Count questions answered. Ready to submit.
        </div>
    }

    <!-- Summary table -->
    <div class="card shadow mb-4">
        <div class="card-body p-0">
            <table class="table table-hover mb-0">
                <thead class="table-light">
                    <tr>
                        <th style="width:60px">#</th>
                        <th>Question</th>
                        <th>Your Answer</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var item in Model)
                    {
                        <tr class="@(item.IsAnswered ? "" : "table-warning")">
                            <td class="fw-bold">@item.DisplayNumber</td>
                            <td>
                                <span class="text-truncate d-inline-block" style="max-width: 420px;"
                                      title="@item.QuestionText">
                                    @item.QuestionText
                                </span>
                            </td>
                            <td>
                                @if (item.IsAnswered)
                                {
                                    <span class="text-success">@item.SelectedOptionText</span>
                                }
                                else
                                {
                                    <span class="text-muted fst-italic">Not answered</span>
                                }
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </div>

    <!-- Final submit form -->
    <form asp-action="SubmitExam" method="post">
        <input type="hidden" name="id" value="@assessmentId" />
        @foreach (var kvp in answers)
        {
            <input type="hidden" name="answers[@kvp.Key]" value="@kvp.Value" />
        }

        <div class="d-flex justify-content-between align-items-center">
            <a asp-action="StartExam" asp-route-id="@assessmentId" class="btn btn-outline-secondary">
                <i class="bi bi-arrow-left me-1"></i>Back to Exam
            </a>

            <button type="submit" class="btn btn-success btn-lg fw-bold"
                    onclick="return confirm('@(unanswered > 0
                        ? $"You have {unanswered} unanswered question(s). Submit anyway?"
                        : "Submit your exam? This cannot be undone.")')">
                <i class="bi bi-check-circle-fill me-2"></i>Submit Exam
            </button>
        </div>
    </form>
</div>
```

**Important:** The "Back to Exam" link goes back to `StartExam GET` with the same assessment ID. Since `UserPackageAssignment` already exists, the user will see their existing assignment with the same shuffled order. Previously entered answers will NOT be pre-filled (they were in JS state), but the user can re-answer and re-submit the summary. This is acceptable behavior.
  </action>
  <verify>
1. `dotnet build` exits 0
2. After completing last exam page, clicking "Review and Submit" shows the summary page
3. Answered questions show selected option text; unanswered rows highlighted in yellow
4. Unanswered count warning shown if applicable
5. Submit button confirms and posts to SubmitExam
6. After submit, redirected to Results page with correct score
  </verify>
  <done>
ExamSummary.cshtml renders all questions with answers. Unanswered warning visible. Submit posts to SubmitExam and redirects to Results. Layout matches existing Bootstrap 5 style.
  </done>
</task>

</tasks>

<verification>
`dotnet build` exits 0. Full flow test: Start exam with packages → answer some questions → navigate pages → Review and Submit → ExamSummary shows answered/unanswered → Submit → Results page shows correct score. Unanswered questions show warning on summary page.
</verification>

<success_criteria>
- ExamSummary GET shows all questions and answers in table
- Unanswered questions highlighted, warning count shown
- Final Submit posts to SubmitExam, redirects to Results
- SubmitExam package path and legacy path are mutually exclusive (if/else — legacy loop cannot fire on a package exam)
- SubmitExam package path grades by PackageOption.IsCorrect (not letter-based), stores score on AssessmentSession.Score correctly
- SubmitExam package path does NOT insert UserResponse rows (FK constraints on AssessmentQuestionId/SelectedOptionId are incompatible with PackageQuestion/PackageOption IDs)
- Legacy path (no packages) still grades via existing AssessmentOption.IsCorrect path
- Results page shows correct score and pass/fail after package-path exam
</success_criteria>

<output>
After completion, create `.planning/phases/17-question-and-exam-ux-improvements/17-06-SUMMARY.md`
</output>
