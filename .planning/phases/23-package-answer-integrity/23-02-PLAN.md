---
phase: 23-package-answer-integrity
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - Controllers/CMPController.cs
  - Views/CMP/Results.cshtml
autonomous: true

must_haves:
  truths:
    - "When AllowAnswerReview is enabled, the Results page for a package-based exam shows each question with the worker's selected answer highlighted and correct/incorrect feedback"
    - "The Results page correctly counts correct answers for package exams in the summary statistics"
    - "Legacy (non-package) exam answer review continues to work identically"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "Results action with package path branch loading PackageUserResponse data"
      contains: "PackageUserResponses"
    - path: "Views/CMP/Results.cshtml"
      provides: "Answer review display (unchanged — uses same QuestionReviewItem ViewModel)"
  key_links:
    - from: "Controllers/CMPController.cs"
      to: "PackageUserResponses"
      via: "Results action queries PackageUserResponse for package-based sessions"
      pattern: "_context\\.PackageUserResponses"
    - from: "Controllers/CMPController.cs"
      to: "AssessmentResultsViewModel.QuestionReviews"
      via: "Package path builds QuestionReviewItem list from PackageUserResponse + PackageQuestion + PackageOption"
      pattern: "new QuestionReviewItem"
---

<objective>
Extend the Results controller action to load PackageUserResponse data for package-based exams and build QuestionReviewItem view models, enabling the existing Results.cshtml answer review UI to display correct/incorrect feedback for package exams.

Purpose: The Results view already renders answer review using QuestionReviewItem/OptionReviewItem — but the Results action only populates these from legacy UserResponse + AssessmentQuestion data. Package exams need the same population path using PackageUserResponse + PackageQuestion + PackageOption.

Output: Workers who completed a package-based exam see full answer review with correct/incorrect highlighting on the Results page, matching the legacy experience.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-package-answer-integrity/23-01-SUMMARY.md
@Models/AssessmentResultsViewModel.cs
@Models/AssessmentPackage.cs
@Models/UserPackageAssignment.cs
@Controllers/CMPController.cs (lines 2357-2452 Results action)
@Views/CMP/Results.cshtml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add package answer review branch to Results action</name>
  <files>Controllers/CMPController.cs</files>
  <action>
In the `Results` action (around line 2358), the current logic loads `assessment.Questions` and `assessment.Responses` for the legacy path. The package path needs a separate branch.

The approach: After the authorization and "must be completed" checks, detect whether this session used a package by querying UserPackageAssignment. If a package assignment exists, load PackageUserResponse + PackageQuestion + PackageOption data instead of the legacy UserResponse + AssessmentQuestion data.

**Detailed changes to the Results action:**

1. After the "Must be completed" check (line ~2384), add a package path detection:

```csharp
// Detect package path
var packageAssignment = await _context.UserPackageAssignments
    .FirstOrDefaultAsync(a => a.AssessmentSessionId == id);
```

2. Restructure the `correctCount` and `questionReviews` building into two branches:

**Package branch (if packageAssignment != null):**
```csharp
if (packageAssignment != null)
{
    // Load package questions with options
    var packageQuestions = await _context.PackageQuestions
        .Include(q => q.Options)
        .Where(q => q.AssessmentPackageId == packageAssignment.AssessmentPackageId)
        .OrderBy(q => q.Order)
        .ToListAsync();

    // Load user responses for this session
    var packageResponses = await _context.PackageUserResponses
        .Where(r => r.AssessmentSessionId == id)
        .ToListAsync();
    var responseDict = packageResponses.ToDictionary(r => r.PackageQuestionId);

    // Use shuffled order from assignment for display
    var shuffledQuestionIds = packageAssignment.GetShuffledQuestionIds();
    var questionLookup = packageQuestions.ToDictionary(q => q.Id);

    // If shuffled IDs are empty (edge case), fall back to natural order
    var orderedQuestionIds = shuffledQuestionIds.Any()
        ? shuffledQuestionIds.Where(qid => questionLookup.ContainsKey(qid)).ToList()
        : packageQuestions.Select(q => q.Id).ToList();

    if (assessment.AllowAnswerReview)
    {
        questionReviews = new List<QuestionReviewItem>();
        int questionNum = 0;
        foreach (var qId in orderedQuestionIds)
        {
            if (!questionLookup.TryGetValue(qId, out var question)) continue;
            questionNum++;

            responseDict.TryGetValue(qId, out var userResponse);
            var correctOption = question.Options.FirstOrDefault(o => o.IsCorrect);
            var selectedOption = userResponse?.PackageOptionId != null
                ? question.Options.FirstOrDefault(o => o.Id == userResponse.PackageOptionId)
                : null;
            bool isCorrect = selectedOption != null && selectedOption.IsCorrect;
            if (isCorrect) correctCount++;

            questionReviews.Add(new QuestionReviewItem
            {
                QuestionNumber = questionNum,
                QuestionText = question.QuestionText,
                UserAnswer = selectedOption?.OptionText,
                CorrectAnswer = correctOption?.OptionText ?? "N/A",
                IsCorrect = isCorrect,
                Options = question.Options.Select(o => new OptionReviewItem
                {
                    OptionText = o.OptionText,
                    IsCorrect = o.IsCorrect,
                    IsSelected = userResponse?.PackageOptionId == o.Id
                }).ToList()
            });
        }
    }
    else
    {
        // Count correct even when review disabled
        foreach (var qId in orderedQuestionIds)
        {
            if (!questionLookup.TryGetValue(qId, out var question)) continue;
            responseDict.TryGetValue(qId, out var userResponse);
            if (userResponse?.PackageOptionId != null)
            {
                var selectedOpt = question.Options.FirstOrDefault(o => o.Id == userResponse.PackageOptionId);
                if (selectedOpt != null && selectedOpt.IsCorrect)
                    correctCount++;
            }
        }
    }

    // TotalQuestions for package path
    var viewModel = new AssessmentResultsViewModel
    {
        AssessmentId = assessment.Id,
        Title = assessment.Title,
        Category = assessment.Category,
        UserFullName = assessment.User?.FullName ?? "Unknown",
        Score = score,
        PassPercentage = passPercentage,
        IsPassed = score >= passPercentage,
        AllowAnswerReview = assessment.AllowAnswerReview,
        CompletedAt = assessment.CompletedAt,
        TotalQuestions = orderedQuestionIds.Count,
        CorrectAnswers = correctCount,
        QuestionReviews = questionReviews
    };

    return View(viewModel);
}
```

**Legacy branch (else — existing code):**
Keep the existing code for the legacy path inside an `else` block. The existing code at lines ~2387-2452 stays as-is, wrapped in the else.

Note: The `assessment` query at the top of Results (lines 2360-2366) includes `.Include(a => a.Questions)` and `.Include(a => a.Responses)`. For the package path, these will be empty (no AssessmentQuestion/UserResponse rows exist). This is fine — the package path uses its own queries.

The `assessment.User` is still needed for `UserFullName`, so keep the `.Include(a => a.User)` in the existing query.

**Important:** Move `var passPercentage = assessment.PassPercentage;` and `var score = assessment.Score ?? 0;` BEFORE the package/legacy branch so both branches can use them.

Also move `var correctCount = 0;` and `List<QuestionReviewItem>? questionReviews = null;` BEFORE the branch (they are already there in the current code, just ensure they remain accessible to both paths).
  </action>
  <verify>
- `dotnet build` compiles without errors
- Grep for `PackageUserResponses` in the Results action — confirms package path exists
- Grep for `packageAssignment != null` in the Results action — confirms branching logic
- The legacy path still builds QuestionReviewItem from `assessment.Questions` and `assessment.Responses`
  </verify>
  <done>Results action has two branches: package path (loads PackageUserResponse + PackageQuestion) and legacy path (existing UserResponse + AssessmentQuestion). Both produce the same AssessmentResultsViewModel/QuestionReviewItem data. Results.cshtml needs no changes — it already renders from the ViewModel.</done>
</task>

</tasks>

<verification>
1. `dotnet build` — project compiles cleanly
2. Grep `PackageUserResponses` in CMPController.cs — appears in Results action (query), SubmitExam (Add from 23-01), ResetAssessment (RemoveRange from 23-01)
3. Results.cshtml unchanged — still uses `@model AssessmentResultsViewModel` with `QuestionReviews` loop
4. Both package and legacy paths produce identical ViewModel structures
</verification>

<success_criteria>
- Package-based exam Results page shows answer review with correct/incorrect highlighting per question when AllowAnswerReview is enabled
- Package-based exam Results page shows correct answer count in summary even when AllowAnswerReview is disabled
- Legacy exam Results page works identically to before (no regression)
- TotalQuestions on Results page reflects the actual number of package questions (not legacy assessment.Questions.Count which would be 0)
</success_criteria>

<output>
After completion, create `.planning/phases/23-package-answer-integrity/23-02-SUMMARY.md`
</output>
