---
phase: 23-package-answer-integrity
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/CMPController.cs
autonomous: true

must_haves:
  truths:
    - "A worker navigating directly to /CMP/StartExam/{id} for a token-protected exam is redirected to the Assessment lobby with an error message, not shown exam content"
    - "A worker who enters a valid token on the Assessment lobby is allowed through to StartExam and sees the exam"
    - "Non-token-protected exams are unaffected — direct URL access works as before"
    - "HC and Admin can access StartExam directly without token check (they are not exam takers, they may need to view the page for debugging)"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "Token enforcement guard in StartExam GET action"
      contains: "IsTokenRequired"
  key_links:
    - from: "Controllers/CMPController.cs (StartExam GET)"
      to: "Assessment lobby"
      via: "RedirectToAction with TempData error when token not validated"
      pattern: "IsTokenRequired.*RedirectToAction"
    - from: "Controllers/CMPController.cs (VerifyToken POST)"
      to: "Session/TempData token flag"
      via: "Sets a session or TempData flag on successful token verification"
      pattern: "TempData.*TokenVerified"
---

<objective>
Enforce token verification in the StartExam GET controller action so that workers cannot bypass the token prompt by navigating directly to the exam URL. The token verification flow on the Assessment lobby remains the entry point; StartExam validates that the worker passed through it.

Purpose: Currently, token enforcement only exists in the Assessment.cshtml lobby view (JavaScript-based modal). A worker who knows or guesses the `/CMP/StartExam/{id}` URL can bypass the token check entirely. Moving enforcement server-side into StartExam GET closes this gap.

Output: Token-protected exams require server-side token validation before rendering exam content; direct URL access without prior token verification is blocked.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Controllers/CMPController.cs (lines 1605-1639 VerifyToken POST; lines 1641-1827 StartExam GET)
@Views/CMP/Assessment.cshtml (lines 470-500 token flow; lines 736-810 JS token modal)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server-side token enforcement to StartExam GET using TempData flag</name>
  <files>Controllers/CMPController.cs</files>
  <action>
The enforcement mechanism uses a TempData flag set by the existing VerifyToken POST action. TempData is ideal because it survives exactly one redirect (Assessment lobby -> VerifyToken -> redirect -> StartExam GET) and then auto-expires.

**Step 1: Modify VerifyToken POST to set a TempData flag on success.**

In the `VerifyToken` action (around line 1607), find the success return at line ~1638:
```csharp
// Token Valid -> Redirect to Exam
return Json(new { success = true, redirectUrl = Url.Action("StartExam", new { id = assessment.Id }) });
```

Just BEFORE that return, add:
```csharp
TempData[$"TokenVerified_{assessment.Id}"] = true;
```

The key is scoped to the assessment ID so verifying token for one exam does not grant access to another.

**Step 2: Also set the TempData flag in the non-token-required branch of VerifyToken.**

In VerifyToken, the `!assessment.IsTokenRequired` branch (line ~1626) also returns success. Add the same flag before the return:
```csharp
TempData[$"TokenVerified_{assessment.Id}"] = true;
```

This ensures the `startStandardAssessment` JS function (which also calls VerifyToken with empty token for non-token exams) also sets the flag. However, the StartExam guard will only check the flag for token-required exams, so this is just for consistency.

**Step 3: Add token guard to StartExam GET action.**

In the `StartExam` GET action (line ~1643), add the token enforcement guard AFTER the authorization check (line ~1653) and AFTER the Completed check (line ~1655), but BEFORE the ExamWindowCloseDate check (line ~1661). The guard should be placed right after the Completed redirect:

```csharp
// Enforce token requirement — workers must verify token via Assessment lobby first (SEC-01)
// HC and Admin bypass: they are not exam takers; they may access StartExam for debugging/monitoring
if (assessment.IsTokenRequired && assessment.UserId == user.Id)
{
    var tokenVerified = TempData[$"TokenVerified_{id}"];
    // Peek + keep: if verified, allow through; if not, block
    if (tokenVerified == null)
    {
        TempData["Error"] = "Ujian ini membutuhkan token akses. Silakan masukkan token terlebih dahulu.";
        return RedirectToAction("Assessment");
    }
    // Token verified — allow through (TempData is consumed on read, which is correct:
    // if the worker reloads the exam page, they are already InProgress so the token is
    // only needed for initial entry)
}
```

**Guard placement rationale:**
- After Completed check: completed exams redirect to Assessment anyway.
- Before ExamWindowCloseDate check: token check is logically "can you enter?" before "is the window still open?"
- Before Abandoned check: an abandoned session redirects regardless.
- Before InProgress write: the token must be verified before we set status to InProgress.
- HC/Admin bypass: `assessment.UserId == user.Id` is true only for the exam owner (the worker). HC/Admin viewing someone else's exam are not the owner, so they bypass. Admin in their own exam session would need a token, which is correct behavior.

**Important edge case — InProgress re-entry:** When a worker reloads the exam page after already being marked InProgress, the TempData flag will have been consumed on the first request. This is fine because:
1. If the worker's session is already InProgress (`assessment.StartedAt != null`), they should still be able to re-enter.
2. Modify the guard to also skip if the session is already InProgress:

```csharp
if (assessment.IsTokenRequired && assessment.UserId == user.Id && assessment.StartedAt == null)
{
    var tokenVerified = TempData[$"TokenVerified_{id}"];
    if (tokenVerified == null)
    {
        TempData["Error"] = "Ujian ini membutuhkan token akses. Silakan masukkan token terlebih dahulu.";
        return RedirectToAction("Assessment");
    }
}
```

The `assessment.StartedAt == null` condition means:
- First visit (StartedAt null): token required -> checked
- Subsequent visits (StartedAt set, already InProgress): token not checked -> worker can reload

This is secure because:
- On first visit, the token must be validated
- After InProgress, the worker is already in the exam — no point re-checking the token
- If the session is Reset (StartedAt cleared), the next StartExam visit will require the token again
  </action>
  <verify>
- `dotnet build` compiles without errors
- Grep for `TokenVerified_` in CMPController.cs — appears in both VerifyToken (set) and StartExam (check)
- Grep for `IsTokenRequired.*StartedAt` in StartExam — confirms the guard condition
- The guard is placed after the Completed check and before the ExamWindowCloseDate check in StartExam
  </verify>
  <done>
- Token-protected exams enforce server-side token verification in StartExam GET
- Direct URL access to /CMP/StartExam/{id} without prior token verification redirects to Assessment lobby with error message
- Workers who verified their token through the Assessment lobby modal are allowed through
- InProgress sessions (reloads) skip the token check — token is only required on initial entry
- HC/Admin bypass the token check (they are not the session owner)
- Non-token-protected exams are unaffected
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` — project compiles cleanly
2. Grep for `TokenVerified_` in CMPController.cs — set in VerifyToken, checked in StartExam
3. The guard in StartExam is positioned: after Completed check, before ExamWindowCloseDate check
4. The guard condition includes `assessment.StartedAt == null` for re-entry support
5. The guard condition includes `assessment.UserId == user.Id` for HC/Admin bypass
</verification>

<success_criteria>
- Worker navigating to /CMP/StartExam/{id} for a token-protected exam (with StartedAt == null) without going through VerifyToken is redirected to Assessment lobby with Indonesian error message
- Worker who enters correct token on Assessment lobby modal is redirected to StartExam and sees the exam
- Worker who reloads the exam page after InProgress is not blocked by the token check
- HC/Admin accessing StartExam for a token-protected exam they do not own are not blocked
- Non-token-protected exams work exactly as before
</success_criteria>

<output>
After completion, create `.planning/phases/23-package-answer-integrity/23-03-SUMMARY.md`
</output>
