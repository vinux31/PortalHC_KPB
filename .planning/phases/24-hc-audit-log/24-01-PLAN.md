---
phase: 24-hc-audit-log
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Models/AuditLog.cs
  - Data/ApplicationDbContext.cs
  - Services/AuditLogService.cs
  - Controllers/CMPController.cs
  - Migrations/<generated>_AddAuditLog.cs
autonomous: true

must_haves:
  truths:
    - "Every CreateAssessment POST writes an audit log row with actor, action type, and assessment title"
    - "Every EditAssessment POST writes an audit log row capturing the edit and bulk-assign (if any)"
    - "Every DeleteAssessment and DeleteAssessmentGroup POST writes an audit log row before deletion"
    - "Every ForceCloseAssessment POST writes an audit log row with the affected user name"
    - "Every ResetAssessment POST writes an audit log row with the affected user name"
  artifacts:
    - path: "Models/AuditLog.cs"
      provides: "AuditLog entity with Id, ActorUserId, ActorName, ActionType, Description, TargetId, TargetType, CreatedAt"
      contains: "public class AuditLog"
    - path: "Services/AuditLogService.cs"
      provides: "Scoped DI service with LogAsync helper method"
      contains: "public class AuditLogService"
    - path: "Data/ApplicationDbContext.cs"
      provides: "AuditLogs DbSet registered"
      contains: "DbSet<AuditLog> AuditLogs"
  key_links:
    - from: "Controllers/CMPController.cs"
      to: "Services/AuditLogService.cs"
      via: "constructor-injected _auditLog field"
      pattern: "_auditLog\\.LogAsync"
    - from: "Services/AuditLogService.cs"
      to: "Data/ApplicationDbContext.cs"
      via: "DbContext injection, _context.AuditLogs.AddAsync"
      pattern: "_context\\.AuditLogs"
---

<objective>
Create the AuditLog entity, EF migration, and AuditLogService; then instrument all HC assessment management actions in CMPController with audit log calls.

Purpose: Establishes the audit trail infrastructure and wires it into every HC management action so that all creates, edits, deletes, force-closes, and resets are recorded with actor identity and timestamp.

Output: AuditLog table in database, AuditLogService registered in DI, all 7 action methods in CMPController calling the service.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Controllers/CMPController.cs
@Data/ApplicationDbContext.cs
@Models/ApplicationUser.cs
@Models/AssessmentSession.cs
@Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuditLog entity, DbContext registration, EF migration, and AuditLogService</name>
  <files>
    Models/AuditLog.cs
    Data/ApplicationDbContext.cs
    Services/AuditLogService.cs
    Program.cs
  </files>
  <action>
**1. Create `Models/AuditLog.cs`:**

```csharp
using System.ComponentModel.DataAnnotations;

namespace HcPortal.Models
{
    public class AuditLog
    {
        public int Id { get; set; }

        /// <summary>
        /// ASP.NET Identity user ID of the actor who performed the action.
        /// </summary>
        [Required]
        public string ActorUserId { get; set; } = "";

        /// <summary>
        /// Display-friendly actor name (NIP + FullName), captured at write time
        /// so the log remains readable even if the user is later deleted.
        /// </summary>
        [Required]
        public string ActorName { get; set; } = "";

        /// <summary>
        /// Machine-readable action type. Values:
        /// CreateAssessment, EditAssessment, BulkAssign,
        /// DeleteAssessment, DeleteAssessmentGroup,
        /// ForceCloseAssessment, ResetAssessment
        /// </summary>
        [Required]
        [MaxLength(50)]
        public string ActionType { get; set; } = "";

        /// <summary>
        /// Human-readable description of what happened, e.g.
        /// "Created assessment 'Safety OJT' for 5 users"
        /// </summary>
        [Required]
        public string Description { get; set; } = "";

        /// <summary>
        /// Optional: primary key of the target entity (e.g., AssessmentSession.Id).
        /// Nullable because group deletes have no single target.
        /// </summary>
        public int? TargetId { get; set; }

        /// <summary>
        /// Optional: type name of the target entity (e.g., "AssessmentSession").
        /// </summary>
        [MaxLength(100)]
        public string? TargetType { get; set; }

        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }
}
```

**2. Register DbSet in `Data/ApplicationDbContext.cs`:**

Add after the `PackageUserResponses` DbSet line (around line 56):

```csharp
// Audit Log — Phase 24
public DbSet<AuditLog> AuditLogs { get; set; }
```

In `OnModelCreating`, add after the PackageUserResponse configuration block (before the closing `}` of OnModelCreating):

```csharp
// ========== Audit Log (Phase 24) ==========
builder.Entity<AuditLog>(entity =>
{
    entity.HasIndex(a => a.CreatedAt);
    entity.HasIndex(a => a.ActorUserId);
    entity.HasIndex(a => a.ActionType);
    entity.Property(a => a.CreatedAt).HasDefaultValueSql("GETUTCDATE()");
});
```

**3. Create `Services/AuditLogService.cs`:**

Create the `Services/` directory (it does not yet exist). Register as a scoped service injected with ApplicationDbContext.

```csharp
using HcPortal.Data;
using HcPortal.Models;

namespace HcPortal.Services
{
    /// <summary>
    /// Simple audit log writer. Injected into controllers that need audit logging.
    /// </summary>
    public class AuditLogService
    {
        private readonly ApplicationDbContext _context;

        public AuditLogService(ApplicationDbContext context)
        {
            _context = context;
        }

        /// <summary>
        /// Write one audit log row. Calls SaveChangesAsync internally.
        /// </summary>
        public async Task LogAsync(
            string actorUserId,
            string actorName,
            string actionType,
            string description,
            int? targetId = null,
            string? targetType = null)
        {
            var entry = new AuditLog
            {
                ActorUserId = actorUserId,
                ActorName = actorName,
                ActionType = actionType,
                Description = description,
                TargetId = targetId,
                TargetType = targetType,
                CreatedAt = DateTime.UtcNow
            };

            _context.AuditLogs.Add(entry);
            await _context.SaveChangesAsync();
        }
    }
}
```

**4. Register in DI in `Program.cs`:**

Add after the `builder.Services.AddIdentity<>` block (around line 26):

```csharp
builder.Services.AddScoped<HcPortal.Services.AuditLogService>();
```

**5. Run EF migration:**

```bash
dotnet ef migrations add AddAuditLog
dotnet ef database update
```

  </action>
  <verify>
1. `dotnet build` compiles without errors.
2. Migration file exists in `Migrations/` with `AddAuditLog` in the name.
3. `dotnet ef database update` succeeds (AuditLogs table created).
4. Grep confirms: `DbSet<AuditLog> AuditLogs` in ApplicationDbContext.cs.
5. Grep confirms: `AddScoped<.*AuditLogService>` in Program.cs.
  </verify>
  <done>
AuditLog entity exists with all 8 fields. AuditLogs DbSet is registered in ApplicationDbContext with CreatedAt, ActorUserId, and ActionType indexes. AuditLogService is a scoped DI service with a LogAsync method. EF migration applied successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument all HC assessment management actions with audit log calls</name>
  <files>
    Controllers/CMPController.cs
  </files>
  <action>
**1. Inject AuditLogService into CMPController:**

Add `using HcPortal.Services;` to the top of the file (after the existing using statements).

Add a new field to the controller class:

```csharp
private readonly AuditLogService _auditLog;
```

Update the constructor to accept and store it:

```csharp
public CMPController(
    UserManager<ApplicationUser> userManager,
    SignInManager<ApplicationUser> signInManager,
    ApplicationDbContext context,
    IWebHostEnvironment env,
    AuditLogService auditLog)
{
    _userManager = userManager;
    _signInManager = signInManager;
    _context = context;
    _env = env;
    _auditLog = auditLog;
}
```

**2. Instrument CreateAssessment POST (line ~901):**

The `currentUser` variable is already fetched at line ~1009. AFTER the `await transaction.CommitAsync();` call (line ~1077), inside the try block, before the `createdSessions` population loop, add:

```csharp
// Audit log
var actorName = $"{currentUser?.NIP ?? "?"} - {currentUser?.FullName ?? "Unknown"}";
await _auditLog.LogAsync(
    currentUser?.Id ?? "",
    actorName,
    "CreateAssessment",
    $"Created assessment '{model.Title}' ({model.Category}) scheduled {model.Schedule:yyyy-MM-dd} for {sessions.Count} user(s)",
    sessions.FirstOrDefault()?.Id,
    "AssessmentSession");
```

**3. Instrument EditAssessment POST (line ~550):**

After the successful `await _context.SaveChangesAsync()` at line ~600 (inside the try block, before the TempData["Success"] assignment), add:

```csharp
// Audit log — edit
var editUser = await _userManager.GetUserAsync(User);
var editActorName = $"{editUser?.NIP ?? "?"} - {editUser?.FullName ?? "Unknown"}";
await _auditLog.LogAsync(
    editUser?.Id ?? "",
    editActorName,
    "EditAssessment",
    $"Edited assessment '{assessment.Title}' ({assessment.Category}) [ID={id}]",
    id,
    "AssessmentSession");
```

Additionally, instrument the **bulk-assign** success path. After `await transaction.CommitAsync();` at line ~679, before the TempData assignment, add:

```csharp
// Audit log — bulk assign
await _auditLog.LogAsync(
    editUser?.Id ?? "",
    editActorName,
    "BulkAssign",
    $"Assigned {newSessions.Count} new user(s) to assessment '{savedAssessment.Title}' ({savedAssessment.Category})",
    id,
    "AssessmentSession");
```

Note: `editUser` and `editActorName` are declared earlier in this method. The `editUser` variable is already in scope because it was declared in the outer block. Move the `editUser` / `editActorName` declarations to BEFORE the try block at line ~597 so both the edit log and bulk-assign log can use them.

**4. Instrument DeleteAssessment POST (line ~706):**

After `await _context.SaveChangesAsync()` at line ~753, before the success log, add:

```csharp
// Audit log
var deleteUser = await _userManager.GetUserAsync(User);
var deleteActorName = $"{deleteUser?.NIP ?? "?"} - {deleteUser?.FullName ?? "Unknown"}";
await _auditLog.LogAsync(
    deleteUser?.Id ?? "",
    deleteActorName,
    "DeleteAssessment",
    $"Deleted assessment '{assessmentTitle}' [ID={id}]",
    id,
    "AssessmentSession");
```

**5. Instrument DeleteAssessmentGroup POST (line ~769):**

After `await _context.SaveChangesAsync()` at line ~815, before the success log, add:

```csharp
// Audit log
var dgUser = await _userManager.GetUserAsync(User);
var dgActorName = $"{dgUser?.NIP ?? "?"} - {dgUser?.FullName ?? "Unknown"}";
await _auditLog.LogAsync(
    dgUser?.Id ?? "",
    dgActorName,
    "DeleteAssessmentGroup",
    $"Deleted assessment group '{rep.Title}' ({rep.Category}) — {siblings.Count} session(s)",
    representativeId,
    "AssessmentSession");
```

**6. Instrument ForceCloseAssessment POST (line ~453):**

After `await _context.SaveChangesAsync()` at line ~480, before the TempData["Success"] assignment, add:

```csharp
// Audit log
var fcUser = await _userManager.GetUserAsync(User);
var fcActorName = $"{fcUser?.NIP ?? "?"} - {fcUser?.FullName ?? "Unknown"}";
await _auditLog.LogAsync(
    fcUser?.Id ?? "",
    fcActorName,
    "ForceCloseAssessment",
    $"Force-closed assessment '{assessment.Title}' for user {assessment.UserId} [ID={id}]",
    id,
    "AssessmentSession");
```

**7. Instrument ResetAssessment POST (line ~389):**

After `await _context.SaveChangesAsync()` at line ~438, before the TempData["Success"] assignment, add:

```csharp
// Audit log
var rsUser = await _userManager.GetUserAsync(User);
var rsActorName = $"{rsUser?.NIP ?? "?"} - {rsUser?.FullName ?? "Unknown"}";
await _auditLog.LogAsync(
    rsUser?.Id ?? "",
    rsActorName,
    "ResetAssessment",
    $"Reset assessment '{assessment.Title}' for user {assessment.UserId} [ID={id}]",
    id,
    "AssessmentSession");
```

**Important notes:**
- All audit log calls go AFTER the primary SaveChangesAsync — if the main operation fails, no audit row is written (correct behavior).
- Audit log failures must NOT break the main operation. Wrap each `_auditLog.LogAsync()` in a try/catch that logs to ILogger but does NOT rethrow. Example:
  ```csharp
  try { await _auditLog.LogAsync(...); }
  catch (Exception ex) { logger.LogWarning(ex, "Audit log write failed"); }
  ```
  Apply this pattern for DeleteAssessment and DeleteAssessmentGroup (which already have a logger variable in scope). For the other actions, the audit call can be unguarded since the whole method is already in a stable state after SaveChanges.
- `editUser` / `editActorName` in EditAssessment POST must be declared at a scope visible to both the edit and bulk-assign audit calls.
  </action>
  <verify>
1. `dotnet build` compiles without errors.
2. Grep confirms `_auditLog.LogAsync` appears 7 times in CMPController.cs (CreateAssessment, EditAssessment, BulkAssign, DeleteAssessment, DeleteAssessmentGroup, ForceCloseAssessment, ResetAssessment).
3. Grep confirms `AuditLogService _auditLog` field exists in CMPController.
4. Grep confirms `using HcPortal.Services;` at top of CMPController.cs.
  </verify>
  <done>
All 7 HC assessment management actions in CMPController write an audit log row after successful completion. Each row captures: actor NIP+name, action type, human-readable description with assessment title and relevant counts, target entity ID, and timestamp. Constructor injection of AuditLogService is wired.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `dotnet build` succeeds with zero errors.
2. AuditLogs table exists in database with correct schema (Id, ActorUserId, ActorName, ActionType, Description, TargetId, TargetType, CreatedAt).
3. AuditLogService is registered as scoped in DI container.
4. All 7 audit points are wired: CreateAssessment, EditAssessment, BulkAssign, DeleteAssessment, DeleteAssessmentGroup, ForceCloseAssessment, ResetAssessment.
5. Audit calls occur AFTER successful SaveChangesAsync — no phantom audit rows on failed operations.
</verification>

<success_criteria>
- AuditLog model, migration, DbSet, indexes, and DI service all exist and build cleanly.
- Every HC assessment management action writes an audit row with actor NIP/name, action type, description, and timestamp.
- The audit log service is a simple scoped class — no over-engineered abstractions.
</success_criteria>

<output>
After completion, create `.planning/phases/24-hc-audit-log/24-01-SUMMARY.md`
</output>
