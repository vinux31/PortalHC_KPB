---
phase: 29-auto-transition-upcoming-to-open
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/CMPController.cs
autonomous: true

must_haves:
  truths:
    - "A worker whose assessment has Status=Upcoming and Schedule.Date <= today sees it as Open on their assessment list without HC taking any action"
    - "A worker whose assessment has a future Schedule.Date still sees Status=Upcoming and cannot start the exam"
    - "HC monitoring dashboard shows an assessment group as Open (not Upcoming) when the scheduled date has arrived, on the next AJAX call"
    - "No stale Upcoming state is served after the scheduled date passes — the transition is applied on every relevant page load and AJAX call"
    - "GetMonitorData does not persist any changes to the database — the transition is display-only in that endpoint"
    - "StartExam persists the Upcoming→Open transition to the database before checking status or marking InProgress"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "Auto-transition logic applied at all three read locations"
      contains: "Schedule.Date <= DateTime.UtcNow.Date"
  key_links:
    - from: "Controllers/CMPController.cs (GetMonitorData)"
      to: "groupStatus logic (line ~329)"
      via: "in-memory status override applied before GroupBy/Select groupStatus check"
      pattern: "Schedule\\.Date <= DateTime\\.UtcNow\\.Date"
    - from: "Controllers/CMPController.cs (Assessment worker list)"
      to: "View(exams)"
      via: "in-memory status override applied to exams list after ToListAsync"
      pattern: "exams.*ForEach|foreach.*exams"
    - from: "Controllers/CMPController.cs (StartExam)"
      to: "SaveChangesAsync"
      via: "Upcoming→Open mutation with SaveChangesAsync before existing status checks"
      pattern: "Status == \"Upcoming\".*Schedule\\.Date"
---

<objective>
Apply auto-transition from Upcoming to Open status at all three read locations in CMPController.cs: the HC monitoring AJAX endpoint (GetMonitorData, display-only), the worker assessment list (display-only), and the StartExam action (persisted).

Purpose: Workers and HC must see Open status as soon as the scheduled date arrives — no manual HC action required (SCHED-01). The transition must be deterministic on every read after the scheduled date passes.
Output: Modified CMPController.cs with transition logic at three call sites. No new files needed.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-auto-transition-upcoming-to-open/29-RESEARCH.md
@Controllers/CMPController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply display-only auto-transition in GetMonitorData</name>
  <files>Controllers/CMPController.cs</files>
  <action>
In GetMonitorData (around line 269), the sessions are fetched via a `.Select()` projection into an anonymous type and stored in `monitorSessions`. The status in these anonymous objects is a plain string — we cannot call `.Status =` on them directly. Instead, after the `.ToListAsync()` call, project `monitorSessions` into a new list (or use a local helper variable) where each item's `Status` is replaced with `"Open"` if it was `"Upcoming"` and `Schedule.Date <= DateTime.UtcNow.Date`. Do NOT call SaveChangesAsync — this is display-only.

The cleanest approach: after `.ToListAsync()`, project into a new list of the same anonymous shape using `.Select(a => new { ... a.Status = (a.Status == "Upcoming" && a.Schedule.Date <= DateTime.UtcNow.Date) ? "Open" : a.Status, ... })`. Replace the existing `monitorSessions` variable with this projected result.

Specifically:
1. Read the current `.Select(a => new { a.Id, a.Title, a.Category, a.Schedule, a.Status, a.Score, a.IsPassed, a.CompletedAt, a.StartedAt, UserFullName = ..., UserNIP = ... })` projection (lines ~284-298).
2. After the `.ToListAsync()` call that produces `monitorSessions`, add a re-projection step:

```csharp
var today = DateTime.UtcNow.Date;
monitorSessions = monitorSessions
    .Select(a => new
    {
        a.Id,
        a.Title,
        a.Category,
        a.Schedule,
        Status = (a.Status == "Upcoming" && a.Schedule.Date <= today) ? "Open" : a.Status,
        a.Score,
        a.IsPassed,
        a.CompletedAt,
        a.StartedAt,
        UserFullName = a.UserFullName,
        UserNIP      = a.UserNIP
    })
    .ToList();
```

3. The re-projected list replaces `monitorSessions`. The existing grouping and `groupStatus` logic that follows (which checks `a.Status == "Open"` and `a.Status == "Upcoming"`) will now receive the corrected statuses automatically — no further changes needed in that logic.

Do not alter the database filter (the `.Where()` clause still includes `Status == "Upcoming"` to fetch sessions that need transition). Do not add SaveChangesAsync.
  </action>
  <verify>
After the change, search for the re-projection block in CMPController.cs:
- Confirm `DateTime.UtcNow.Date` appears in GetMonitorData
- Confirm `SaveChangesAsync` is NOT called in GetMonitorData (grep for SaveChangesAsync in that method scope — should not appear)
- Confirm the existing `groupStatus` logic (`hasOpen`, `hasUpcoming` checks around line 329) is unchanged
  </verify>
  <done>
GetMonitorData applies the Upcoming→Open status override in-memory before grouping. An assessment group where all sessions have Schedule.Date <= today will display GroupStatus "Open" instead of "Upcoming". No database writes occur in this endpoint.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply persisted auto-transition in StartExam + display-only in worker assessment list</name>
  <files>Controllers/CMPController.cs</files>
  <action>
**Part A — StartExam (persist):**

In StartExam (around line 2082), after loading `assessment` and after the null check (`if (assessment == null) return NotFound()`), but BEFORE any status checks (before the `if (assessment.Status == "Completed")` check), insert the Upcoming→Open transition:

```csharp
// Auto-transition: Upcoming → Open when scheduled date has arrived
if (assessment.Status == "Upcoming" && assessment.Schedule.Date <= DateTime.UtcNow.Date)
{
    assessment.Status = "Open";
    assessment.UpdatedAt = DateTime.UtcNow;
    await _context.SaveChangesAsync();
}
```

This saves the Open status to the database immediately, so subsequent reads (by siblings, by the same worker, by HC monitoring) will see "Open" from DB. After this block, the existing status checks (Completed block, token check, ExamWindowCloseDate check, Abandoned block) all execute against the now-correct status. The existing `if (assessment.StartedAt == null)` → `InProgress` block is unaffected.

Important: place this block AFTER the null check and BEFORE the `if (assessment.Status == "Completed")` check on line ~2094. This ensures the transition is applied before any access decisions are made.

Do NOT also apply sibling transitions here — the worker can only reach StartExam for their own session ID. The GetMonitorData display-only transition handles sibling display. Keeping StartExam to a single-session save avoids unexpected side-effects and keeps the SaveChangesAsync pattern simple.

**Part B — Worker assessment list (display-only):**

In the worker personal branch of the `Assessment` action (around line 229), after `exams` is populated via `.ToListAsync()` and before `return View(exams)`, apply the in-memory transition:

```csharp
// Auto-transition display: show Upcoming as Open when scheduled date has arrived
var today = DateTime.UtcNow.Date;
foreach (var exam in exams)
{
    if (exam.Status == "Upcoming" && exam.Schedule.Date <= today)
        exam.Status = "Open";
}
```

These `exams` are tracked EF entities, so do NOT call SaveChangesAsync after this loop — the in-memory mutation will be discarded when the request ends. The view receives the corrected statuses and renders the "Open" badge and Start button for assessments due today or earlier.

Note: `totalCount2` and pagination are computed from the DB query BEFORE the in-memory transition. This is correct — the count includes both Open and Upcoming sessions (workers should still see the count even if status display changes).
  </action>
  <verify>
1. In StartExam scope: confirm `"Upcoming"` and `Schedule.Date <= DateTime.UtcNow.Date` appear together in a condition before the `Status == "Completed"` check.
2. In StartExam scope: confirm a `SaveChangesAsync` call follows immediately inside the Upcoming→Open block (separate from the InProgress SaveChangesAsync below it).
3. In worker list scope (around line 229-264): confirm a foreach loop iterating `exams` with the same `"Upcoming" && Schedule.Date <= DateTime.UtcNow.Date` condition exists between `ToListAsync()` and `return View(exams)`.
4. In worker list scope: confirm there is NO `SaveChangesAsync` call after the foreach loop.
  </verify>
  <done>
StartExam persists the Upcoming→Open transition so the assessment status is correct in the DB after the first access. Worker assessment list shows assessments due today or earlier as Open without requiring DB writes. Workers can navigate to StartExam for a due assessment (which was Upcoming in DB) because the StartExam action itself transitions and persists before the status checks run.
  </done>
</task>

</tasks>

<verification>
1. Grep CMPController.cs for `Schedule.Date <= DateTime.UtcNow.Date` — should appear in at least 3 locations (GetMonitorData, StartExam, worker list foreach).
2. Confirm GetMonitorData has zero `SaveChangesAsync` calls.
3. Confirm StartExam has a `SaveChangesAsync` call inside the `Status == "Upcoming"` transition block (before the InProgress block).
4. Confirm worker list foreach loop has no `SaveChangesAsync` after it.
5. Manual test path: create an assessment with Status="Upcoming" and Schedule.Date = today or yesterday → worker list shows "Open" → worker can navigate to StartExam → exam loads → DB row now has Status="Open".
6. Manual test path: assessment with Schedule.Date = tomorrow → worker list shows "Upcoming" → StartExam is inaccessible (status check passes but worker shouldn't have reached it via Assessment list link since Upcoming UI likely doesn't show a Start button — verify the view renders correctly).
</verification>

<success_criteria>
1. Assessment with Status=Upcoming and Schedule.Date <= today displays as Open in worker assessment list, GetMonitorData HC dashboard, and is startable via StartExam — all without HC taking any manual action.
2. Assessment with Schedule.Date in the future remains Upcoming and the worker sees no Start button.
3. After the first worker access to StartExam for a due Upcoming session, the DB row has Status=Open.
4. GetMonitorData contains no SaveChangesAsync call — the transition is purely display-side in that endpoint.
5. The existing groupStatus logic in GetMonitorData (`hasOpen`, `hasUpcoming`) correctly reflects Open for sessions that have passed their scheduled date.
</success_criteria>

<output>
After completion, create `.planning/phases/29-auto-transition-upcoming-to-open/29-01-SUMMARY.md`
</output>
