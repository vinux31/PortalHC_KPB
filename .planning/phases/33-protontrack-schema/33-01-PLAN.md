---
phase: 33-protontrack-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Models/ProtonModels.cs
  - Data/ApplicationDbContext.cs
  - Migrations/<timestamp>_CreateProtonTrackTable.cs
  - Migrations/ApplicationDbContextModelSnapshot.cs
autonomous: true
must_haves:
  truths:
    - "A ProtonTracks table exists in the database with Id, TrackType, TahunKe, DisplayName, and Urutan columns"
    - "ProtonKompetensiList rows each have a non-null ProtonTrackId FK pointing to a row in ProtonTracks"
    - "ProtonTrackAssignments rows each have a non-null ProtonTrackId FK pointing to a row in ProtonTracks"
    - "The old TrackType and TahunKe string columns are absent from both ProtonKompetensiList and ProtonTrackAssignments"
    - "Exactly 6 ProtonTrack rows exist after migration: Panelman × Tahun 1/2/3 and Operator × Tahun 1/2/3"
    - "All pre-existing ProtonKompetensi and ProtonTrackAssignment rows are preserved with correct ProtonTrackId values"
  artifacts:
    - path: "Models/ProtonModels.cs"
      provides: "ProtonTrack entity class with Id, TrackType, TahunKe, DisplayName, Urutan, and KompetensiList navigation"
      contains: "class ProtonTrack"
    - path: "Data/ApplicationDbContext.cs"
      provides: "DbSet<ProtonTrack>, FK configuration for ProtonKompetensi (Cascade) and ProtonTrackAssignment (Restrict)"
      contains: "DbSet<ProtonTrack>"
    - path: "Migrations/*_CreateProtonTrackTable.cs"
      provides: "Single atomic migration: create table, seed 6 tracks via MERGE, add nullable FKs, backfill, validate, make non-null, drop string cols"
      contains: "CreateProtonTrackTable"
  key_links:
    - from: "Models/ProtonModels.cs ProtonKompetensi"
      to: "Models/ProtonModels.cs ProtonTrack"
      via: "ProtonTrackId FK property (int, non-null)"
      pattern: "public int ProtonTrackId"
    - from: "Models/ProtonModels.cs ProtonTrackAssignment"
      to: "Models/ProtonModels.cs ProtonTrack"
      via: "ProtonTrackId FK property (int, non-null) and navigation ProtonTrack?"
      pattern: "public ProtonTrack\\? ProtonTrack"
    - from: "Data/ApplicationDbContext.cs"
      to: "Models/ProtonModels.cs ProtonTrack"
      via: "DbSet<ProtonTrack> ProtonTracks and OnModelCreating FK config"
      pattern: "DbSet<ProtonTrack>"
    - from: "Migrations/*_CreateProtonTrackTable.cs"
      to: "ProtonTrackAssignments.ProtonTrackId"
      via: "SQL UPDATE backfill joined on TrackType+TahunKe, then AlterColumn NOT NULL, then DropColumn"
      pattern: "DropColumn.*TrackType.*ProtonTrackAssignments"
---

<objective>
Create the ProtonTrack entity, register it in DbContext, and run a single atomic EF migration that introduces the ProtonTracks table, seeds exactly 6 track rows, backfills ProtonTrackId FK on both ProtonKompetensiList and ProtonTrackAssignments, enforces NOT NULL, and drops the old TrackType+TahunKe string columns from both tables.

Purpose: Establish ProtonTrack as the normalized single source of truth for track identity, eliminating string duplication from two tables in one atomic operation. Phase 34 and beyond query ProtonTrack directly.

Output: ProtonTrack entity + EF migration applied to the database. ProtonKompetensi and ProtonTrackAssignment no longer carry TrackType/TahunKe string fields.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-protontrack-schema/33-CONTEXT.md
@.planning/phases/33-protontrack-schema/33-RESEARCH.md
@Models/ProtonModels.cs
@Data/ApplicationDbContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ProtonTrack entity and update ProtonKompetensi + ProtonTrackAssignment models</name>
  <files>Models/ProtonModels.cs</files>
  <action>
    Add the ProtonTrack class at the top of ProtonModels.cs, before ProtonKompetensi:

    ```csharp
    /// <summary>
    /// Normalized track entity — single source of truth for Proton track identifiers (Phase 33)
    /// </summary>
    public class ProtonTrack
    {
        public int Id { get; set; }
        /// <summary>Values: "Panelman" or "Operator"</summary>
        public string TrackType { get; set; } = "";
        /// <summary>Values: "Tahun 1", "Tahun 2", "Tahun 3"</summary>
        public string TahunKe { get; set; } = "";
        /// <summary>Auto-generated at seed time. Format: "Panelman - Tahun 1" (TrackType + " - " + TahunKe)</summary>
        public string DisplayName { get; set; } = "";
        /// <summary>Display order in UI dropdowns (1-6)</summary>
        public int Urutan { get; set; }

        // Navigation property — one Track has many Kompetensi
        public ICollection<ProtonKompetensi> KompetensiList { get; set; } = new List<ProtonKompetensi>();
    }
    ```

    Then update ProtonKompetensi: remove `TrackType` and `TahunKe` string properties, add:
    ```csharp
    public int ProtonTrackId { get; set; }
    public ProtonTrack? ProtonTrack { get; set; }
    ```
    Keep all other properties (Id, NamaKompetensi, Urutan, SubKompetensiList) unchanged.

    Then update ProtonTrackAssignment: remove `TrackType` and `TahunKe` string properties, add:
    ```csharp
    public int ProtonTrackId { get; set; }
    public ProtonTrack? ProtonTrack { get; set; }
    ```
    Keep all other properties (Id, CoacheeId, AssignedById, IsActive, AssignedAt) unchanged.

    Do NOT touch ProtonSubKompetensi, ProtonDeliverable, ProtonDeliverableProgress, ProtonNotification, ProtonFinalAssessment.
  </action>
  <verify>
    Build the project: `dotnet build` — should compile with 0 errors.
    Confirm the file no longer contains `public string TrackType` or `public string TahunKe` on ProtonKompetensi or ProtonTrackAssignment.
    Confirm `class ProtonTrack` exists with Id, TrackType, TahunKe, DisplayName, Urutan, KompetensiList.
  </verify>
  <done>
    `dotnet build` passes. ProtonKompetensi and ProtonTrackAssignment have ProtonTrackId (int) + ProtonTrack? navigation. ProtonTrack class exists with the 6 properties. Old string TrackType/TahunKe fields are gone from both entity classes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register ProtonTrack in DbContext and configure FK relationships</name>
  <files>Data/ApplicationDbContext.cs</files>
  <action>
    1. Add DbSet after the existing Proton DbSets (around line 48):
    ```csharp
    // Proton Track (Phase 33 — normalized track entity)
    public DbSet<ProtonTrack> ProtonTracks { get; set; }
    ```

    2. In OnModelCreating, add ProtonTrack configuration in the "Proton Deliverable Tracking configuration (Phase 5)" section, BEFORE the existing ProtonSubKompetensi config. Add:

    ```csharp
    // ProtonTrack entity configuration (Phase 33)
    builder.Entity<ProtonTrack>(entity =>
    {
        entity.ToTable("ProtonTracks");
        entity.HasKey(t => t.Id);
        entity.HasIndex(t => new { t.TrackType, t.TahunKe }).IsUnique();
        entity.Property(t => t.TrackType).IsRequired().HasMaxLength(50);
        entity.Property(t => t.TahunKe).IsRequired().HasMaxLength(50);
        entity.Property(t => t.DisplayName).IsRequired().HasMaxLength(100);
    });

    // ProtonKompetensi -> ProtonTrack (Phase 33)
    builder.Entity<ProtonKompetensi>(entity =>
    {
        entity.HasOne(k => k.ProtonTrack)
            .WithMany(t => t.KompetensiList)
            .HasForeignKey(k => k.ProtonTrackId)
            .OnDelete(DeleteBehavior.Cascade);
        entity.HasIndex(k => k.ProtonTrackId);
    });

    // ProtonTrackAssignment -> ProtonTrack (Phase 33)
    builder.Entity<ProtonTrackAssignment>(entity =>
    {
        entity.HasOne(a => a.ProtonTrack)
            .WithMany()
            .HasForeignKey(a => a.ProtonTrackId)
            .OnDelete(DeleteBehavior.Restrict);
        entity.HasIndex(a => a.ProtonTrackId);
    });
    ```

    3. The existing `builder.Entity<ProtonTrackAssignment>` block at the bottom of the Proton section (which only configures indexes for CoacheeId and IsActive) must be merged into the new block above — do not create a duplicate entity configuration for ProtonTrackAssignment. Move the existing CoacheeId index and IsActive composite index into the new block.

    Important: DeleteBehavior.Cascade for Kompetensi (deleting a track cascades to its kompetensi), DeleteBehavior.Restrict for TrackAssignment (preserve assignment history — do not auto-delete assignments when a track is deleted).
  </action>
  <verify>
    `dotnet build` passes with 0 errors.
    Confirm `DbSet<ProtonTrack> ProtonTracks` exists in the context.
    Confirm OnModelCreating has ProtonTrack entity config with unique index on (TrackType, TahunKe).
    Confirm ProtonKompetensi FK uses DeleteBehavior.Cascade and ProtonTrackAssignment FK uses DeleteBehavior.Restrict.
  </verify>
  <done>
    `dotnet build` passes. DbContext has ProtonTracks DbSet. OnModelCreating configures ProtonTrack with unique constraint and configures both FK relationships with correct cascade behaviors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Generate and write the EF Core migration with full data migration logic</name>
  <files>
    Migrations/&lt;timestamp&gt;_CreateProtonTrackTable.cs
    Migrations/ApplicationDbContextModelSnapshot.cs
  </files>
  <action>
    Run the EF scaffold command to generate a migration skeleton:
    ```
    dotnet ef migrations add CreateProtonTrackTable
    ```

    After generation, open the new migration file and implement the full Up() method. The auto-generated scaffolding will partially fill it — replace/augment with the complete logic below in this exact order:

    **Step 1 — Create ProtonTracks table:**
    Use migrationBuilder.CreateTable for "ProtonTracks" with columns: Id (int identity PK), TrackType (nvarchar(50) not null), TahunKe (nvarchar(50) not null), DisplayName (nvarchar(100) not null), Urutan (int not null). Add a UniqueConstraint on (TrackType, TahunKe).

    **Step 2 — Add nullable FK columns to both child tables:**
    ```csharp
    migrationBuilder.AddColumn<int>(name: "ProtonTrackId", table: "ProtonKompetensiList", type: "int", nullable: true);
    migrationBuilder.AddColumn<int>(name: "ProtonTrackId", table: "ProtonTrackAssignments", type: "int", nullable: true);
    ```

    **Step 3 — Create indexes for the new FK columns:**
    ```csharp
    migrationBuilder.CreateIndex(name: "IX_ProtonKompetensiList_ProtonTrackId", table: "ProtonKompetensiList", column: "ProtonTrackId");
    migrationBuilder.CreateIndex(name: "IX_ProtonTrackAssignments_ProtonTrackId", table: "ProtonTrackAssignments", column: "ProtonTrackId");
    ```

    **Step 4 — Add FK constraints (while columns are still nullable):**
    ```csharp
    migrationBuilder.AddForeignKey(
        name: "FK_ProtonKompetensiList_ProtonTracks_ProtonTrackId",
        table: "ProtonKompetensiList",
        column: "ProtonTrackId",
        principalTable: "ProtonTracks",
        principalColumn: "Id",
        onDelete: ReferentialAction.Cascade);

    migrationBuilder.AddForeignKey(
        name: "FK_ProtonTrackAssignments_ProtonTracks_ProtonTrackId",
        table: "ProtonTrackAssignments",
        column: "ProtonTrackId",
        principalTable: "ProtonTracks",
        principalColumn: "Id",
        onDelete: ReferentialAction.Restrict);
    ```

    **Step 5 — Seed 6 ProtonTrack rows via defensive MERGE (handles any data drift):**
    ```csharp
    migrationBuilder.Sql(@"
        WITH ExpectedTracks AS (
            SELECT 'Panelman' AS TrackType, 'Tahun 1' AS TahunKe, 'Panelman - Tahun 1' AS DisplayName, 1 AS Urutan
            UNION ALL SELECT 'Panelman', 'Tahun 2', 'Panelman - Tahun 2', 2
            UNION ALL SELECT 'Panelman', 'Tahun 3', 'Panelman - Tahun 3', 3
            UNION ALL SELECT 'Operator', 'Tahun 1', 'Operator - Tahun 1', 4
            UNION ALL SELECT 'Operator', 'Tahun 2', 'Operator - Tahun 2', 5
            UNION ALL SELECT 'Operator', 'Tahun 3', 'Operator - Tahun 3', 6
        )
        MERGE INTO ProtonTracks pt
        USING ExpectedTracks et ON pt.TrackType = et.TrackType AND pt.TahunKe = et.TahunKe
        WHEN NOT MATCHED THEN
            INSERT (TrackType, TahunKe, DisplayName, Urutan)
            VALUES (et.TrackType, et.TahunKe, et.DisplayName, et.Urutan);
    ");
    ```

    **Step 6 — Backfill ProtonKompetensiList.ProtonTrackId:**
    ```csharp
    migrationBuilder.Sql(@"
        UPDATE pk
        SET pk.ProtonTrackId = pt.Id
        FROM ProtonKompetensiList pk
        INNER JOIN ProtonTracks pt ON pk.TrackType = pt.TrackType AND pk.TahunKe = pt.TahunKe
        WHERE pk.ProtonTrackId IS NULL;
    ");
    ```

    **Step 7 — Backfill ProtonTrackAssignments.ProtonTrackId:**
    ```csharp
    migrationBuilder.Sql(@"
        UPDATE pta
        SET pta.ProtonTrackId = pt.Id
        FROM ProtonTrackAssignments pta
        INNER JOIN ProtonTracks pt ON pta.TrackType = pt.TrackType AND pta.TahunKe = pt.TahunKe
        WHERE pta.ProtonTrackId IS NULL;
    ");
    ```

    **Step 8 — Validate no NULLs remain (fail loudly if backfill incomplete):**
    ```csharp
    migrationBuilder.Sql(@"
        IF (SELECT COUNT(*) FROM ProtonKompetensiList WHERE ProtonTrackId IS NULL) > 0
            RAISERROR('ProtonKompetensiList has NULL ProtonTrackId after backfill — migration aborted', 16, 1);
        IF (SELECT COUNT(*) FROM ProtonTrackAssignments WHERE ProtonTrackId IS NULL) > 0
            RAISERROR('ProtonTrackAssignments has NULL ProtonTrackId after backfill — migration aborted', 16, 1);
    ");
    ```

    **Step 9 — Make FK columns NOT NULL:**
    ```csharp
    migrationBuilder.AlterColumn<int>(name: "ProtonTrackId", table: "ProtonKompetensiList",
        type: "int", nullable: false, oldClrType: typeof(int), oldType: "int", oldNullable: true);
    migrationBuilder.AlterColumn<int>(name: "ProtonTrackId", table: "ProtonTrackAssignments",
        type: "int", nullable: false, oldClrType: typeof(int), oldType: "int", oldNullable: true);
    ```

    **Step 10 — Drop old string columns from both tables:**
    ```csharp
    migrationBuilder.DropColumn(name: "TrackType", table: "ProtonKompetensiList");
    migrationBuilder.DropColumn(name: "TahunKe", table: "ProtonKompetensiList");
    migrationBuilder.DropColumn(name: "TrackType", table: "ProtonTrackAssignments");
    migrationBuilder.DropColumn(name: "TahunKe", table: "ProtonTrackAssignments");
    ```

    **Down() method** should reverse in the opposite order: restore TrackType+TahunKe columns as nullable nvarchar(50), drop FK constraints, drop ProtonTrackId indexes, drop ProtonTrackId columns, drop ProtonTracks table. Backfill of the old string columns in Down() is not required (rollback scenario accepted as data loss for string cols).

    After implementing the migration, apply it:
    ```
    dotnet ef database update
    ```

    Checklist before applying:
    - Step 1: ProtonTracks table created with unique constraint
    - Step 2: Nullable FK columns added to both tables
    - Step 3: Indexes created for FK columns
    - Step 4: FK constraints added (while nullable)
    - Step 5: 6 ProtonTrack rows seeded via MERGE
    - Step 6: ProtonKompetensiList.ProtonTrackId backfilled
    - Step 7: ProtonTrackAssignments.ProtonTrackId backfilled
    - Step 8: NULL validation with RAISERROR
    - Step 9: Both FK columns made NOT NULL
    - Step 10: TrackType + TahunKe columns dropped from both tables
  </action>
  <verify>
    Run the following SQL queries against the database to verify:

    ```sql
    -- Must return 6
    SELECT COUNT(*) FROM ProtonTracks;

    -- Must return 0 (no NULL FKs in kompetensi)
    SELECT COUNT(*) FROM ProtonKompetensiList WHERE ProtonTrackId IS NULL;

    -- Must return 0 (no NULL FKs in assignments)
    SELECT COUNT(*) FROM ProtonTrackAssignments WHERE ProtonTrackId IS NULL;

    -- Must fail with column not found (old cols dropped)
    SELECT TOP 1 TrackType FROM ProtonKompetensiList;
    SELECT TOP 1 TrackType FROM ProtonTrackAssignments;

    -- Verify exactly 6 expected tracks with correct DisplayName format
    SELECT TrackType, TahunKe, DisplayName, Urutan FROM ProtonTracks ORDER BY Urutan;
    ```

    Expected ProtonTracks result:
    | TrackType | TahunKe | DisplayName | Urutan |
    |-----------|---------|-------------|--------|
    | Panelman  | Tahun 1 | Panelman - Tahun 1 | 1 |
    | Panelman  | Tahun 2 | Panelman - Tahun 2 | 2 |
    | Panelman  | Tahun 3 | Panelman - Tahun 3 | 3 |
    | Operator  | Tahun 1 | Operator - Tahun 1 | 4 |
    | Operator  | Tahun 2 | Operator - Tahun 2 | 5 |
    | Operator  | Tahun 3 | Operator - Tahun 3 | 6 |

    Also run `dotnet build` to confirm the solution still compiles.
  </verify>
  <done>
    Migration applied successfully. ProtonTracks table has 6 rows. ProtonKompetensiList and ProtonTrackAssignments have non-null ProtonTrackId column and no longer have TrackType or TahunKe string columns. `dotnet build` passes.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, run this full verification sequence:

1. `dotnet build` — 0 errors, 0 warnings related to ProtonTrack changes
2. `dotnet ef migrations list` — CreateProtonTrackTable shows as Applied
3. SQL verification queries from Task 3 — all assertions pass
4. Confirm `Models/ProtonModels.cs` no longer has TrackType/TahunKe on ProtonKompetensi or ProtonTrackAssignment (grep check)
5. Confirm `Data/ApplicationDbContext.cs` has `DbSet<ProtonTrack>` and DeleteBehavior.Cascade/Restrict configured correctly

NOTE: After this plan completes, the codebase will NOT compile cleanly for running (CDPController and SeedProtonData still reference removed string properties). That is expected — Plan 02 fixes those consumers. The build check in Task 3 verifies schema artifacts only; full runtime functionality is verified after Plan 02.
</verification>

<success_criteria>
- ProtonTrack entity class exists in Models/ProtonModels.cs
- ProtonKompetensi.ProtonTrackId and ProtonTrackAssignment.ProtonTrackId are int (non-null) FK properties
- ApplicationDbContext has DbSet&lt;ProtonTrack&gt; ProtonTracks and FK relationships configured
- EF migration CreateProtonTrackTable is applied to the database
- Database has exactly 6 ProtonTracks rows with DisplayName format "TrackType - TahunKe"
- ProtonKompetensiList and ProtonTrackAssignments have no NULL ProtonTrackId values
- TrackType and TahunKe columns are absent from both ProtonKompetensiList and ProtonTrackAssignments tables
</success_criteria>

<output>
After completion, create `.planning/phases/33-protontrack-schema/33-01-SUMMARY.md`
</output>
