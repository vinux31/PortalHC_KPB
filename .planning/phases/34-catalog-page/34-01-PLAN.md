---
phase: 34-catalog-page
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/ProtonCatalogController.cs
  - Models/ProtonViewModels.cs
autonomous: true

must_haves:
  truths:
    - "GET /ProtonCatalog loads without error for HC/Admin users; non-HC/Admin users receive 403"
    - "GET /ProtonCatalog?trackId=1 populates ViewBag.KompetensiList with Kompetensi rows for that track, each with nested SubKompetensiList and Deliverables"
    - "GET /ProtonCatalog/GetCatalogTree?trackId=1 returns partial HTML (not a full page) with the tree for track 1"
    - "POST /ProtonCatalog/AddTrack with valid trackType + tahunKe creates a new ProtonTrack and returns JSON {success:true, trackId, displayName}"
    - "POST /ProtonCatalog/AddTrack with duplicate trackType + tahunKe returns JSON {success:false, error:'[DisplayName] already exists'}"
  artifacts:
    - path: "Controllers/ProtonCatalogController.cs"
      provides: "Index GET, GetCatalogTree GET, AddTrack POST actions"
      contains: "class ProtonCatalogController"
    - path: "Models/ProtonViewModels.cs"
      provides: "ProtonCatalogViewModel with Tracks list and optional KompetensiList"
      contains: "class ProtonCatalogViewModel"
  key_links:
    - from: "Controllers/ProtonCatalogController.cs Index"
      to: "Data/ApplicationDbContext.cs ProtonTracks"
      via: "_context.ProtonTracks.OrderBy(t => t.Urutan).ToListAsync()"
      pattern: "_context\\.ProtonTracks"
    - from: "Controllers/ProtonCatalogController.cs Index"
      to: "Data/ApplicationDbContext.cs ProtonKompetensiList"
      via: "_context.ProtonKompetensiList.Include(SubKompetensiList).ThenInclude(Deliverables).Where(ProtonTrackId == trackId)"
      pattern: "ThenInclude.*Deliverables"
    - from: "Controllers/ProtonCatalogController.cs AddTrack"
      to: "Data/ApplicationDbContext.cs ProtonTracks"
      via: "duplicate check FirstOrDefaultAsync + Add + SaveChangesAsync"
      pattern: "SaveChangesAsync"
---

<objective>
Create ProtonCatalogController and add ProtonCatalogViewModel to the existing ProtonViewModels.cs.

Purpose: The controller is the server-side backbone for Phase 34. It gates access (HC/Admin only), loads the track dropdown data, conditionally pre-loads the tree on server-side render, provides a GET AJAX endpoint for tree reload on track change, and handles the Add Track modal POST.

Output: ProtonCatalogController.cs (new file), ProtonCatalogViewModel class appended to Models/ProtonViewModels.cs.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-catalog-page/34-RESEARCH.md
@Controllers/CDPController.cs
@Models/ProtonModels.cs
@Models/ProtonViewModels.cs
@Data/ApplicationDbContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProtonCatalogController with Index, GetCatalogTree, and AddTrack actions</name>
  <files>Controllers/ProtonCatalogController.cs</files>
  <action>
Create `Controllers/ProtonCatalogController.cs` as a new file. Follow the exact namespace, using-block, and constructor pattern from CDPController.cs. The controller does NOT inject `IWebHostEnvironment` or `SignInManager` — only `UserManager<ApplicationUser>` and `ApplicationDbContext`.

**Authorization guard (shared by all actions):** At the top of Index and GetCatalogTree, get the current user via `_userManager.GetUserAsync(User)`. If null, return `Challenge()`. If `user.RoleLevel > 2`, return `Forbid()`. This enforces HC (RoleLevel 2) and Admin (RoleLevel 1) only — the same pattern used in `_Layout.cshtml` line 81.

**Index GET action** — signature: `public async Task<IActionResult> Index(int? trackId)`

1. Apply the authorization guard above.
2. Load all tracks: `var tracks = await _context.ProtonTracks.OrderBy(t => t.Urutan).ToListAsync();`
3. Set `ViewBag.AllTracks = tracks;` and `ViewBag.SelectedTrackId = trackId;`
4. If `trackId.HasValue`, load the tree: `_context.ProtonKompetensiList.Include(k => k.SubKompetensiList).ThenInclude(s => s.Deliverables).Where(k => k.ProtonTrackId == trackId.Value).OrderBy(k => k.Urutan).ToListAsync()` — set as `ViewBag.KompetensiList`.
5. Return `View()` (no model needed — data is in ViewBag).

**GetCatalogTree GET action** — signature: `public async Task<IActionResult> GetCatalogTree(int trackId)`

This is the AJAX endpoint called when the user changes the track dropdown. It returns partial HTML only.

1. Apply the authorization guard.
2. If `trackId <= 0`, return `PartialView("_CatalogTree", new List<ProtonKompetensi>())`.
3. Load kompetensi with full include chain (same as Index step 4 above).
4. Return `PartialView("_CatalogTree", kompetensiList)`.

No `[ValidateAntiForgeryToken]` needed — GET is safe.

**AddTrack POST action** — signature: `[HttpPost] [ValidateAntiForgeryToken] public async Task<IActionResult> AddTrack(string trackType, string tahunKe)`

This endpoint receives form-encoded POST from the AJAX modal submit and returns JSON.

1. Apply the authorization guard (return `Json(new { success = false, error = "Unauthorized" })` on failure, not Forbid, to preserve AJAX error handling).
2. Input validation: if either param is null/whitespace, return `Json(new { success = false, error = "Input tidak valid." })`.
3. Allowed values check:
   - `allowedTypes = new[] { "Panelman", "Operator" }`
   - `allowedYears = new[] { "Tahun 1", "Tahun 2", "Tahun 3" }`
   - If either input is not in its allowed list, return `Json(new { success = false, error = "Pilihan tidak valid." })`.
4. Duplicate check: `var existing = await _context.ProtonTracks.FirstOrDefaultAsync(t => t.TrackType == trackType && t.TahunKe == tahunKe);`
   - If found: build `displayName = $"{trackType} - {tahunKe}"` and return `Json(new { success = false, error = $"{displayName} already exists" })`.
5. If no duplicate:
   - `displayName = $"{trackType} - {tahunKe}"`
   - Compute `urutan`: `var maxUrutan = await _context.ProtonTracks.AnyAsync() ? await _context.ProtonTracks.MaxAsync(t => t.Urutan) : 0;`
   - Create: `new ProtonTrack { TrackType = trackType, TahunKe = tahunKe, DisplayName = displayName, Urutan = maxUrutan + 1 }`
   - Add and save: `_context.ProtonTracks.Add(newTrack); await _context.SaveChangesAsync();`
   - Return `Json(new { success = true, trackId = newTrack.Id, displayName = displayName })`.

**Usings required** (match CDPController.cs pattern):
```
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using HcPortal.Models;
using HcPortal.Data;
```

Namespace: `namespace HcPortal.Controllers`

Class declaration: `[Authorize] public class ProtonCatalogController : Controller`
  </action>
  <verify>
    Run `dotnet build` from the project root. The build must succeed with 0 errors. Specifically confirm:
    - `ProtonCatalogController` compiles without "type or namespace not found" errors
    - `ProtonKompetensiList`, `ProtonTracks`, `ProtonTrack` all resolve (they are in ApplicationDbContext and ProtonModels.cs)
    - `ThenInclude(s => s.Deliverables)` resolves — `ProtonSubKompetensi` has `ICollection<ProtonDeliverable> Deliverables`
  </verify>
  <done>
    `dotnet build` exits with code 0. ProtonCatalogController.cs exists at Controllers/ProtonCatalogController.cs with three actions: Index (GET), GetCatalogTree (GET), AddTrack (POST with ValidateAntiForgeryToken).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ProtonCatalogViewModel to ProtonViewModels.cs</name>
  <files>Models/ProtonViewModels.cs</files>
  <action>
Append `ProtonCatalogViewModel` to the end of `Models/ProtonViewModels.cs`. Do NOT remove or modify any existing classes (ProtonMainViewModel, ProtonPlanViewModel, DeliverableViewModel, etc.).

Add this class after the last existing class in the file:

```csharp
/// <summary>
/// ViewModel for ProtonCatalog/Index page (Phase 34 CAT-01, CAT-02)
/// HC/Admin view the full Kompetensi → SubKompetensi → Deliverable tree for a selected track.
/// </summary>
public class ProtonCatalogViewModel
{
    /// <summary>All ProtonTrack rows ordered by Urutan — populates the track dropdown.</summary>
    public List<ProtonTrack> AllTracks { get; set; } = new();

    /// <summary>Currently selected track Id from query param; null when no track selected.</summary>
    public int? SelectedTrackId { get; set; }

    /// <summary>
    /// Full Kompetensi tree for the selected track.
    /// Each Kompetensi has SubKompetensiList loaded, each SubKompetensi has Deliverables loaded.
    /// Empty when no track is selected.
    /// </summary>
    public List<ProtonKompetensi> KompetensiList { get; set; } = new();
}
```

Note: The Index action currently passes data via ViewBag (not a typed model). This ViewModel exists so the view can optionally use it and for future phases to reference a typed contract. The controller may pass this as the model or continue using ViewBag — either pattern is acceptable for Phase 34.
  </action>
  <verify>
    Run `dotnet build` from the project root. Build must succeed with 0 errors. Grep `ProtonCatalogViewModel` in `Models/ProtonViewModels.cs` to confirm the class was appended.
  </verify>
  <done>
    `Models/ProtonViewModels.cs` contains `class ProtonCatalogViewModel` with `AllTracks`, `SelectedTrackId`, and `KompetensiList` properties. All pre-existing classes in the file are unchanged.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `dotnet build` exits with code 0, zero errors.
2. `Controllers/ProtonCatalogController.cs` exists and is non-empty.
3. `grep "class ProtonCatalogController" Controllers/ProtonCatalogController.cs` returns a match.
4. `grep "GetCatalogTree\|AddTrack\|Index" Controllers/ProtonCatalogController.cs` shows all three action methods.
5. `grep "class ProtonCatalogViewModel" Models/ProtonViewModels.cs` returns a match.
6. `grep "ProtonKompetensiList\|ThenInclude" Controllers/ProtonCatalogController.cs` confirms the include chain is present.
</verification>

<success_criteria>
- ProtonCatalogController exists with Index, GetCatalogTree, and AddTrack actions
- RoleLevel guard (> 2 = Forbid) present in all actions
- AddTrack duplicate check uses `FirstOrDefaultAsync` on `TrackType + TahunKe` combination
- AddTrack returns `{ success, error }` or `{ success, trackId, displayName }` JSON
- ProtonCatalogViewModel appended to ProtonViewModels.cs without disturbing existing classes
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/34-catalog-page/34-01-SUMMARY.md`
</output>
