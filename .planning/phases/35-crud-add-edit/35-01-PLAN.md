---
phase: 35-crud-add-edit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/ProtonCatalogController.cs
autonomous: true

must_haves:
  truths:
    - "POST /ProtonCatalog/AddKompetensi accepts trackId + nama, persists a new ProtonKompetensi with Urutan=max+1, returns JSON {success, id, nama, urutan}"
    - "POST /ProtonCatalog/AddSubKompetensi accepts kompetensiId + nama, persists a new ProtonSubKompetensi under the correct parent, returns JSON {success, id, nama, urutan}"
    - "POST /ProtonCatalog/AddDeliverable accepts subKompetensiId + nama, persists a new ProtonDeliverable under the correct parent, returns JSON {success, id, nama, urutan}"
    - "POST /ProtonCatalog/EditCatalogItem accepts level + itemId + nama, updates the correct entity name and returns JSON {success}"
    - "All four endpoints enforce RoleLevel > 2 guard (unauthorized returns JSON {success:false, error:'Unauthorized'})"
    - "All four endpoints carry [ValidateAntiForgeryToken]"
  artifacts:
    - path: "Controllers/ProtonCatalogController.cs"
      provides: "Four new POST actions: AddKompetensi, AddSubKompetensi, AddDeliverable, EditCatalogItem"
      contains: "AddKompetensi|AddSubKompetensi|AddDeliverable|EditCatalogItem"
  key_links:
    - from: "Controllers/ProtonCatalogController.cs AddKompetensi"
      to: "_context.ProtonKompetensiList"
      via: "EF Core Add + SaveChangesAsync"
      pattern: "_context\\.ProtonKompetensiList\\.Add"
    - from: "Controllers/ProtonCatalogController.cs AddSubKompetensi"
      to: "_context.ProtonSubKompetensiList"
      via: "EF Core Add + SaveChangesAsync"
      pattern: "_context\\.ProtonSubKompetensiList\\.Add"
    - from: "Controllers/ProtonCatalogController.cs AddDeliverable"
      to: "_context.ProtonDeliverables"
      via: "EF Core Add + SaveChangesAsync"
      pattern: "_context\\.ProtonDeliverables\\.Add"
    - from: "Controllers/ProtonCatalogController.cs EditCatalogItem"
      to: "ProtonKompetensi|ProtonSubKompetensi|ProtonDeliverable"
      via: "switch on level string + FindAsync + SaveChangesAsync"
      pattern: "switch.*level|case \"Kompetensi\""
---

<objective>
Add four POST actions to ProtonCatalogController that allow HC/Admin to create Kompetensi, SubKompetensi, and Deliverables, and rename any existing catalog item — all via JSON AJAX responses.

Purpose: Provides the server-side contract that the Phase 35-02 frontend will call. All business logic (Urutan computation, parent validation, entity routing) lives here so the frontend only handles DOM.
Output: ProtonCatalogController extended with AddKompetensi, AddSubKompetensi, AddDeliverable, and EditCatalogItem actions.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-catalog-page/34-01-SUMMARY.md
@Controllers/ProtonCatalogController.cs
@Models/ProtonModels.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AddKompetensi, AddSubKompetensi, AddDeliverable POST actions</name>
  <files>Controllers/ProtonCatalogController.cs</files>
  <action>
Append three new POST actions to ProtonCatalogController, after the existing AddTrack action. Each follows the same guard + Urutan + persist + JSON pattern already established by AddTrack.

**AddKompetensi:**
```csharp
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> AddKompetensi(int trackId, string nama)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (trackId <= 0 || string.IsNullOrWhiteSpace(nama))
        return Json(new { success = false, error = "Input tidak valid." });

    var trackExists = await _context.ProtonTracks.AnyAsync(t => t.Id == trackId);
    if (!trackExists)
        return Json(new { success = false, error = "Track tidak ditemukan." });

    var maxUrutan = await _context.ProtonKompetensiList.AnyAsync(k => k.ProtonTrackId == trackId)
        ? await _context.ProtonKompetensiList.Where(k => k.ProtonTrackId == trackId).MaxAsync(k => k.Urutan)
        : 0;

    var item = new ProtonKompetensi
    {
        ProtonTrackId = trackId,
        NamaKompetensi = nama.Trim(),
        Urutan = maxUrutan + 1
    };
    _context.ProtonKompetensiList.Add(item);
    await _context.SaveChangesAsync();
    return Json(new { success = true, id = item.Id, nama = item.NamaKompetensi, urutan = item.Urutan });
}
```

**AddSubKompetensi:**
```csharp
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> AddSubKompetensi(int kompetensiId, string nama)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (kompetensiId <= 0 || string.IsNullOrWhiteSpace(nama))
        return Json(new { success = false, error = "Input tidak valid." });

    var parentExists = await _context.ProtonKompetensiList.AnyAsync(k => k.Id == kompetensiId);
    if (!parentExists)
        return Json(new { success = false, error = "Kompetensi tidak ditemukan." });

    var maxUrutan = await _context.ProtonSubKompetensiList.AnyAsync(s => s.ProtonKompetensiId == kompetensiId)
        ? await _context.ProtonSubKompetensiList.Where(s => s.ProtonKompetensiId == kompetensiId).MaxAsync(s => s.Urutan)
        : 0;

    var item = new ProtonSubKompetensi
    {
        ProtonKompetensiId = kompetensiId,
        NamaSubKompetensi = nama.Trim(),
        Urutan = maxUrutan + 1
    };
    _context.ProtonSubKompetensiList.Add(item);
    await _context.SaveChangesAsync();
    return Json(new { success = true, id = item.Id, nama = item.NamaSubKompetensi, urutan = item.Urutan });
}
```

**AddDeliverable:**
```csharp
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> AddDeliverable(int subKompetensiId, string nama)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (subKompetensiId <= 0 || string.IsNullOrWhiteSpace(nama))
        return Json(new { success = false, error = "Input tidak valid." });

    var parentExists = await _context.ProtonSubKompetensiList.AnyAsync(s => s.Id == subKompetensiId);
    if (!parentExists)
        return Json(new { success = false, error = "SubKompetensi tidak ditemukan." });

    var maxUrutan = await _context.ProtonDeliverables.AnyAsync(d => d.ProtonSubKompetensiId == subKompetensiId)
        ? await _context.ProtonDeliverables.Where(d => d.ProtonSubKompetensiId == subKompetensiId).MaxAsync(d => d.Urutan)
        : 0;

    var item = new ProtonDeliverable
    {
        ProtonSubKompetensiId = subKompetensiId,
        NamaDeliverable = nama.Trim(),
        Urutan = maxUrutan + 1
    };
    _context.ProtonDeliverables.Add(item);
    await _context.SaveChangesAsync();
    return Json(new { success = true, id = item.Id, nama = item.NamaDeliverable, urutan = item.Urutan });
}
```

The DbSet names to use — confirm against ApplicationDbContext. The existing controller already uses `_context.ProtonKompetensiList` (confirmed in GetCatalogTree). Use the same DbSet names. For SubKompetensi and Deliverables, check ApplicationDbContext for the exact DbSet property names and use them consistently.
  </action>
  <verify>
Run `dotnet build` from the project root. Filter output for `error CS` — zero errors expected. Confirm all three new action methods exist in Controllers/ProtonCatalogController.cs by grepping for `AddKompetensi`, `AddSubKompetensi`, `AddDeliverable`.
  </verify>
  <done>
`dotnet build` compiles with no C# errors. `Controllers/ProtonCatalogController.cs` contains the three new POST actions, each with [HttpPost] + [ValidateAntiForgeryToken], RoleLevel guard, AnyAsync + MaxAsync Urutan computation, EF Add + SaveChangesAsync, and JSON return.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add EditCatalogItem POST action</name>
  <files>Controllers/ProtonCatalogController.cs</files>
  <action>
Append one more POST action to ProtonCatalogController after the three Add actions.

**EditCatalogItem:**
```csharp
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> EditCatalogItem(string level, int itemId, string nama)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (string.IsNullOrWhiteSpace(level) || itemId <= 0 || string.IsNullOrWhiteSpace(nama))
        return Json(new { success = false, error = "Input tidak valid." });

    switch (level)
    {
        case "Kompetensi":
            var k = await _context.ProtonKompetensiList.FindAsync(itemId);
            if (k == null) return Json(new { success = false, error = "Item tidak ditemukan." });
            k.NamaKompetensi = nama.Trim();
            break;
        case "SubKompetensi":
            var s = await _context.ProtonSubKompetensiList.FindAsync(itemId);
            if (s == null) return Json(new { success = false, error = "Item tidak ditemukan." });
            s.NamaSubKompetensi = nama.Trim();
            break;
        case "Deliverable":
            var d = await _context.ProtonDeliverables.FindAsync(itemId);
            if (d == null) return Json(new { success = false, error = "Item tidak ditemukan." });
            d.NamaDeliverable = nama.Trim();
            break;
        default:
            return Json(new { success = false, error = "Level tidak valid." });
    }

    await _context.SaveChangesAsync();
    return Json(new { success = true });
}
```

Use the exact DbSet property names from ApplicationDbContext. The existing controller already references `_context.ProtonKompetensiList` (confirmed in Index and GetCatalogTree actions). For SubKompetensi and Deliverables DbSet names — read ApplicationDbContext to confirm before writing; do not guess.
  </action>
  <verify>
Run `dotnet build` and confirm zero `error CS` lines. Grep `Controllers/ProtonCatalogController.cs` for `EditCatalogItem` — the action must exist with a switch statement on `level`. Verify the file now has exactly five POST actions total (AddTrack + AddKompetensi + AddSubKompetensi + AddDeliverable + EditCatalogItem).
  </verify>
  <done>
`dotnet build` compiles clean. `Controllers/ProtonCatalogController.cs` contains EditCatalogItem POST action with [ValidateAntiForgeryToken], RoleLevel guard, switch-on-level dispatching to the correct DbSet FindAsync, name update, and SaveChangesAsync. The controller file has five POST actions total.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` from project root produces zero `error CS` lines
2. `Controllers/ProtonCatalogController.cs` contains all five POST actions: AddTrack (existing), AddKompetensi, AddSubKompetensi, AddDeliverable, EditCatalogItem
3. Each new action has [HttpPost] and [ValidateAntiForgeryToken] attributes
4. Each new action has `if (user == null || user.RoleLevel > 2) return Json(new { success = false, error = "Unauthorized" })` guard
5. Each Add action uses AnyAsync + MaxAsync pattern for Urutan computation (consistent with existing AddTrack)
6. EditCatalogItem has a switch on `level` with cases "Kompetensi", "SubKompetensi", "Deliverable" and a default error case
</verification>

<success_criteria>
Four new POST endpoints exist in ProtonCatalogController and compile cleanly:
- AddKompetensi(int trackId, string nama) — returns {success, id, nama, urutan}
- AddSubKompetensi(int kompetensiId, string nama) — returns {success, id, nama, urutan}
- AddDeliverable(int subKompetensiId, string nama) — returns {success, id, nama, urutan}
- EditCatalogItem(string level, int itemId, string nama) — returns {success}

All four enforce HC/Admin-only access. Phase 35-02 frontend can call these endpoints immediately.
</success_criteria>

<output>
After completion, create `.planning/phases/35-crud-add-edit/35-01-SUMMARY.md`
</output>
