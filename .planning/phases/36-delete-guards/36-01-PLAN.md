---
phase: 36-delete-guards
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/ProtonCatalogController.cs
autonomous: true

must_haves:
  truths:
    - "GET /ProtonCatalog/GetDeleteImpact?level=Kompetensi&itemId=1 returns JSON {success, itemName, coacheeCount, subKompetensiCount, deliverableCount}"
    - "GET /ProtonCatalog/GetDeleteImpact?level=SubKompetensi&itemId=1 returns JSON {success, itemName, coacheeCount, deliverableCount} (no subKompetensiCount)"
    - "GET /ProtonCatalog/GetDeleteImpact?level=Deliverable&itemId=1 returns JSON {success, itemName, coacheeCount}"
    - "POST /ProtonCatalog/DeleteCatalogItem deletes in cascade order: ProtonDeliverableProgresses first, then ProtonDeliverableList, then ProtonSubKompetensiList, then ProtonKompetensiList"
    - "DeleteCatalogItem enforces RoleLevel > 2 guard and [ValidateAntiForgeryToken]"
    - "GetDeleteImpact returns {success:false, error:'Unauthorized'} for RoleLevel > 2 (not Forbid — preserve AJAX JSON contract)"
    - "coacheeCount is count of DISTINCT CoacheeId from ProtonDeliverableProgresses where Status != 'Locked' and ProtonDeliverableId is in the set of affected deliverables"
  artifacts:
    - path: "Controllers/ProtonCatalogController.cs"
      provides: "GetDeleteImpact GET action and DeleteCatalogItem POST action"
      contains: "GetDeleteImpact|DeleteCatalogItem"
  key_links:
    - from: "Controllers/ProtonCatalogController.cs GetDeleteImpact"
      to: "_context.ProtonDeliverableProgresses"
      via: "LINQ query counting distinct CoacheeId with Status != Locked"
      pattern: "ProtonDeliverableProgresses.*Distinct|CountAsync.*CoacheeId"
    - from: "Controllers/ProtonCatalogController.cs DeleteCatalogItem"
      to: "_context.ProtonDeliverableProgresses then ProtonDeliverableList then ProtonSubKompetensiList then ProtonKompetensiList"
      via: "bottom-up cascade: RemoveRange each level then SaveChangesAsync once"
      pattern: "RemoveRange.*ProtonDeliverableProgresses|RemoveRange.*ProtonDeliverableList"
---

<objective>
Add GetDeleteImpact GET and DeleteCatalogItem POST to ProtonCatalogController — the two backend endpoints that power the Phase 36 delete guard modal.

Purpose: GetDeleteImpact answers "how many active coachees are affected?" before the user confirms deletion. DeleteCatalogItem performs the cascade delete in the correct bottom-up order to avoid FK constraint violations.
Output: ProtonCatalogController extended with two new actions; DeleteCatalogItem cascades correctly for all three item levels.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-crud-add-edit/35-01-SUMMARY.md
@Controllers/ProtonCatalogController.cs
@Models/ProtonModels.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GetDeleteImpact GET action</name>
  <files>Controllers/ProtonCatalogController.cs</files>
  <action>
Append a new GET action to ProtonCatalogController, after the existing EditCatalogItem action. This action answers the question "what will be deleted, and how many active coachees are affected?" before the user confirms.

The action dispatches on `level` to collect the set of affected ProtonDeliverable IDs, then counts distinct active coachees from ProtonDeliverableProgresses.

**DbSet names confirmed from ApplicationDbContext:**
- `_context.ProtonKompetensiList` — ProtonKompetensi
- `_context.ProtonSubKompetensiList` — ProtonSubKompetensi
- `_context.ProtonDeliverableList` — ProtonDeliverable
- `_context.ProtonDeliverableProgresses` — ProtonDeliverableProgress

**Active coachee definition:** Distinct CoacheeId from ProtonDeliverableProgress where Status != "Locked" and ProtonDeliverableId is in the affected deliverable set.

**Implementation:**

```csharp
// GET: /ProtonCatalog/GetDeleteImpact?level=Kompetensi&itemId=1
[HttpGet]
public async Task<IActionResult> GetDeleteImpact(string level, int itemId)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (string.IsNullOrWhiteSpace(level) || itemId <= 0)
        return Json(new { success = false, error = "Input tidak valid." });

    string itemName;
    List<int> affectedDeliverableIds;
    int subKompetensiCount = 0;
    int deliverableCount = 0;

    switch (level)
    {
        case "Kompetensi":
            var kompetensi = await _context.ProtonKompetensiList
                .Include(k => k.SubKompetensiList)
                    .ThenInclude(s => s.Deliverables)
                .FirstOrDefaultAsync(k => k.Id == itemId);
            if (kompetensi == null)
                return Json(new { success = false, error = "Item tidak ditemukan." });
            itemName = kompetensi.NamaKompetensi;
            subKompetensiCount = kompetensi.SubKompetensiList.Count;
            affectedDeliverableIds = kompetensi.SubKompetensiList
                .SelectMany(s => s.Deliverables)
                .Select(d => d.Id)
                .ToList();
            deliverableCount = affectedDeliverableIds.Count;
            break;

        case "SubKompetensi":
            var sub = await _context.ProtonSubKompetensiList
                .Include(s => s.Deliverables)
                .FirstOrDefaultAsync(s => s.Id == itemId);
            if (sub == null)
                return Json(new { success = false, error = "Item tidak ditemukan." });
            itemName = sub.NamaSubKompetensi;
            affectedDeliverableIds = sub.Deliverables.Select(d => d.Id).ToList();
            deliverableCount = affectedDeliverableIds.Count;
            break;

        case "Deliverable":
            var deliverable = await _context.ProtonDeliverableList
                .FirstOrDefaultAsync(d => d.Id == itemId);
            if (deliverable == null)
                return Json(new { success = false, error = "Item tidak ditemukan." });
            itemName = deliverable.NamaDeliverable;
            affectedDeliverableIds = new List<int> { itemId };
            deliverableCount = 1;
            break;

        default:
            return Json(new { success = false, error = "Level tidak valid." });
    }

    int coacheeCount = 0;
    if (affectedDeliverableIds.Any())
    {
        coacheeCount = await _context.ProtonDeliverableProgresses
            .Where(p => affectedDeliverableIds.Contains(p.ProtonDeliverableId)
                     && p.Status != "Locked")
            .Select(p => p.CoacheeId)
            .Distinct()
            .CountAsync();
    }

    return Json(new
    {
        success = true,
        itemName = itemName,
        coacheeCount = coacheeCount,
        subKompetensiCount = subKompetensiCount,
        deliverableCount = deliverableCount
    });
}
```

Note: `[HttpGet]` is explicit here to document intent, though GET is the default. The existing Index and GetCatalogTree actions also omit explicit [HttpGet] — follow whichever pattern is already used in this file (add [HttpGet] if the others have it, omit if they don't).
  </action>
  <verify>
Run `dotnet build` from the project root. Zero `error CS` lines expected. Grep `Controllers/ProtonCatalogController.cs` for `GetDeleteImpact` — the method must be present with a switch on `level` and a `ProtonDeliverableProgresses` query.
  </verify>
  <done>
`dotnet build` compiles clean. `Controllers/ProtonCatalogController.cs` contains GetDeleteImpact with level-dispatch, affectedDeliverableIds accumulation, and a distinct-CoacheeId count query against ProtonDeliverableProgresses where Status != "Locked".
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DeleteCatalogItem POST action with cascade delete</name>
  <files>Controllers/ProtonCatalogController.cs</files>
  <action>
Append one more POST action after GetDeleteImpact. This action performs the actual deletion in correct bottom-up cascade order to avoid FK constraint violations.

**Cascade order (critical — must follow this exact sequence):**
1. ProtonDeliverableProgresses (progress records referencing deliverables)
2. ProtonDeliverableList (the deliverables themselves)
3. ProtonSubKompetensiList (only when deleting Kompetensi or SubKompetensi)
4. ProtonKompetensiList (only when deleting Kompetensi)

**Implementation:**

```csharp
// POST: /ProtonCatalog/DeleteCatalogItem
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> DeleteCatalogItem(string level, int itemId)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (string.IsNullOrWhiteSpace(level) || itemId <= 0)
        return Json(new { success = false, error = "Input tidak valid." });

    switch (level)
    {
        case "Kompetensi":
            var kompetensi = await _context.ProtonKompetensiList
                .Include(k => k.SubKompetensiList)
                    .ThenInclude(s => s.Deliverables)
                .FirstOrDefaultAsync(k => k.Id == itemId);
            if (kompetensi == null)
                return Json(new { success = false, error = "Item tidak ditemukan." });

            var allDeliverableIds = kompetensi.SubKompetensiList
                .SelectMany(s => s.Deliverables)
                .Select(d => d.Id)
                .ToList();

            if (allDeliverableIds.Any())
            {
                var progresses = await _context.ProtonDeliverableProgresses
                    .Where(p => allDeliverableIds.Contains(p.ProtonDeliverableId))
                    .ToListAsync();
                _context.ProtonDeliverableProgresses.RemoveRange(progresses);
            }

            var allDeliverables = kompetensi.SubKompetensiList
                .SelectMany(s => s.Deliverables)
                .ToList();
            _context.ProtonDeliverableList.RemoveRange(allDeliverables);

            _context.ProtonSubKompetensiList.RemoveRange(kompetensi.SubKompetensiList);
            _context.ProtonKompetensiList.Remove(kompetensi);
            break;

        case "SubKompetensi":
            var sub = await _context.ProtonSubKompetensiList
                .Include(s => s.Deliverables)
                .FirstOrDefaultAsync(s => s.Id == itemId);
            if (sub == null)
                return Json(new { success = false, error = "Item tidak ditemukan." });

            var subDeliverableIds = sub.Deliverables.Select(d => d.Id).ToList();
            if (subDeliverableIds.Any())
            {
                var progresses = await _context.ProtonDeliverableProgresses
                    .Where(p => subDeliverableIds.Contains(p.ProtonDeliverableId))
                    .ToListAsync();
                _context.ProtonDeliverableProgresses.RemoveRange(progresses);
            }

            _context.ProtonDeliverableList.RemoveRange(sub.Deliverables);
            _context.ProtonSubKompetensiList.Remove(sub);
            break;

        case "Deliverable":
            var deliverable = await _context.ProtonDeliverableList
                .FirstOrDefaultAsync(d => d.Id == itemId);
            if (deliverable == null)
                return Json(new { success = false, error = "Item tidak ditemukan." });

            var delivProgresses = await _context.ProtonDeliverableProgresses
                .Where(p => p.ProtonDeliverableId == itemId)
                .ToListAsync();
            _context.ProtonDeliverableProgresses.RemoveRange(delivProgresses);
            _context.ProtonDeliverableList.Remove(deliverable);
            break;

        default:
            return Json(new { success = false, error = "Level tidak valid." });
    }

    await _context.SaveChangesAsync();
    return Json(new { success = true });
}
```

Single `SaveChangesAsync()` call at the end — EF Core batches all the RemoveRange/Remove operations into one transaction. This is the correct pattern (do not call SaveChangesAsync between each RemoveRange — the FK chain requires them to be submitted together within the same transaction).
  </action>
  <verify>
Run `dotnet build` and confirm zero `error CS` lines. Grep `Controllers/ProtonCatalogController.cs` for `DeleteCatalogItem` — the method must be present with [HttpPost] and [ValidateAntiForgeryToken]. Verify the file now has exactly seven actions total (Index, GetCatalogTree, AddTrack, AddKompetensi, AddSubKompetensi, AddDeliverable, EditCatalogItem + GetDeleteImpact + DeleteCatalogItem = 9 total). Count actions by grepping for `public async Task<IActionResult>`.
  </verify>
  <done>
`dotnet build` compiles clean. `Controllers/ProtonCatalogController.cs` contains DeleteCatalogItem with [HttpPost] + [ValidateAntiForgeryToken], RoleLevel guard, switch-on-level dispatch, bottom-up cascade delete (ProtonDeliverableProgresses → ProtonDeliverableList → ProtonSubKompetensiList → ProtonKompetensiList as appropriate per level), and single SaveChangesAsync at the end.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` from project root produces zero `error CS` lines
2. `Controllers/ProtonCatalogController.cs` contains GetDeleteImpact with switch-on-level dispatching, affectedDeliverableIds collection, and ProtonDeliverableProgresses distinct-CoacheeId count where Status != "Locked"
3. `Controllers/ProtonCatalogController.cs` contains DeleteCatalogItem with [HttpPost] + [ValidateAntiForgeryToken]
4. DeleteCatalogItem removes ProtonDeliverableProgresses BEFORE ProtonDeliverableList (cascade order enforced)
5. DeleteCatalogItem removes ProtonDeliverableList BEFORE ProtonSubKompetensiList BEFORE ProtonKompetensiList
6. Both actions return JSON {success:false, error:"Unauthorized"} for RoleLevel > 2 (not Forbid — AJAX JSON contract preserved)
7. Single SaveChangesAsync() at the end of DeleteCatalogItem (not interleaved with each RemoveRange)
</verification>

<success_criteria>
Two new endpoints exist in ProtonCatalogController and compile cleanly:
- GetDeleteImpact(string level, int itemId) — returns {success, itemName, coacheeCount, subKompetensiCount, deliverableCount}; coacheeCount is distinct active coachees (Status != "Locked")
- DeleteCatalogItem(string level, int itemId) — cascades correctly: progress records first, deliverables second, sub-kompetensi third, kompetensi last; single SaveChangesAsync transaction

Phase 36-02 frontend can call these endpoints immediately.
</success_criteria>

<output>
After completion, create `.planning/phases/36-delete-guards/36-01-SUMMARY.md`
</output>
