---
phase: 36-delete-guards
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - Views/ProtonCatalog/_CatalogTree.cshtml
  - Views/ProtonCatalog/Index.cshtml
autonomous: false

must_haves:
  truths:
    - "A trash icon (bi-trash, text-danger) appears to the right of the pencil icon on Kompetensi and SubKompetensi rows when the row is expanded — it is hidden (d-none) when the row is collapsed, exactly mirroring the pencil-btn pattern from Phase 35"
    - "Deliverable rows show both pencil and trash icons always visible (no d-none) — Deliverables have no collapse toggle so they are only visible when their parent SubKompetensi is expanded"
    - "Clicking the trash icon triggers an AJAX GET to /ProtonCatalog/GetDeleteImpact — a shared #deleteModal opens with a loading spinner while the request is in flight"
    - "When impact data arrives, the modal body shows: item name, children count bullets (Kompetensi/SubKompetensi levels only), and a coachee warning line — 0 coachees shows an info line, N coachees shows a warning line"
    - "The modal has a single 'Yes, Delete' btn-danger button — clicking it POSTs to /ProtonCatalog/DeleteCatalogItem; the button is disabled + shows a spinner while the request is in flight"
    - "On delete success, the modal closes and reloadTree() refreshes the tree without a page reload"
    - "On server error, an error alert appears inside the modal body; the modal stays open and the 'Yes, Delete' button is re-enabled for retry"
    - "When 0 coachees are affected, the modal still appears and 'Yes, Delete' is still the only confirmation mechanism — no typing required"
  artifacts:
    - path: "Views/ProtonCatalog/_CatalogTree.cshtml"
      provides: "Trash icon buttons on all three item levels"
      contains: "trash-btn|bi-trash"
    - path: "Views/ProtonCatalog/Index.cshtml"
      provides: "Shared #deleteModal HTML and initDeleteGuards() function called after initCatalogTree()"
      contains: "deleteModal|initDeleteGuards"
  key_links:
    - from: "Views/ProtonCatalog/Index.cshtml initDeleteGuards()"
      to: "/ProtonCatalog/GetDeleteImpact"
      via: "fetch GET on trash-btn click; populates #deleteModal body"
      pattern: "GetDeleteImpact|fetch.*GetDeleteImpact"
    - from: "Views/ProtonCatalog/Index.cshtml #deleteModal confirm button"
      to: "/ProtonCatalog/DeleteCatalogItem"
      via: "postItem() POST with level + itemId + antiforgery token on 'Yes, Delete' click"
      pattern: "DeleteCatalogItem|postItem.*DeleteCatalogItem"
    - from: "Bootstrap collapse show.bs.collapse event"
      to: ".trash-btn d-none removal"
      via: "initCatalogTree() collapse listeners extended to also toggle trash-btn alongside pencil-btn"
      pattern: "trash-btn.*d-none|show\\.bs\\.collapse.*trash"
---

<objective>
Add trash icon buttons to _CatalogTree.cshtml and implement the shared delete guard modal plus initDeleteGuards() wiring in Index.cshtml — completing Phase 36 requirement CAT-07.

Purpose: HC/Admin sees a populated confirmation modal with active coachee impact count before any catalog item is destroyed. The modal guards against accidental deletion by requiring an explicit "Yes, Delete" click.
Output: Trash icons on all tree rows; shared #deleteModal with three-state body (loading / content / error); initDeleteGuards() function wired into the existing initCatalogTree() call chain.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/35-crud-add-edit/35-02-SUMMARY.md
@.planning/phases/36-delete-guards/36-01-SUMMARY.md
@Views/ProtonCatalog/_CatalogTree.cshtml
@Views/ProtonCatalog/Index.cshtml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add trash icon buttons to _CatalogTree.cshtml</name>
  <files>Views/ProtonCatalog/_CatalogTree.cshtml</files>
  <action>
Extend the existing third `<td>` column (the one with `.pencil-btn`) in each row type to include a trash button AFTER the pencil button. Icon order: pencil first, then trash. Per the locked user decisions:

- Kompetensi rows: trash is `d-none` (hidden until row expanded, mirroring pencil-btn pattern)
- SubKompetensi rows: trash is `d-none` (hidden until row expanded, mirroring pencil-btn pattern)
- Deliverable rows: trash has NO `d-none` (leaf node — always visible when parent is expanded)

**Kompetensi row third `<td>` — current state:**
```cshtml
<td class="align-middle text-end pe-2">
    <button type="button"
            class="btn btn-link btn-sm p-0 text-muted pencil-btn d-none"
            data-level="Kompetensi"
            data-id="@kompetensi.Id"
            aria-label="Edit @kompetensi.NamaKompetensi">
        <i class="bi bi-pencil"></i>
    </button>
</td>
```

**Replace with:**
```cshtml
<td class="align-middle text-end pe-2">
    <button type="button"
            class="btn btn-link btn-sm p-0 text-muted pencil-btn d-none me-1"
            data-level="Kompetensi"
            data-id="@kompetensi.Id"
            aria-label="Edit @kompetensi.NamaKompetensi">
        <i class="bi bi-pencil"></i>
    </button>
    <button type="button"
            class="btn btn-link btn-sm p-0 text-danger trash-btn d-none"
            data-level="Kompetensi"
            data-id="@kompetensi.Id"
            aria-label="Delete @kompetensi.NamaKompetensi">
        <i class="bi bi-trash"></i>
    </button>
</td>
```

**SubKompetensi row third `<td>` — apply the same pattern:**
Add the trash button after the pencil button. Both have `d-none`. Use `data-level="SubKompetensi"` and `data-id="@sub.Id"`.

**Deliverable row third `<td>` — current state:**
```cshtml
<td class="align-middle text-end pe-2">
    <button type="button"
            class="btn btn-link btn-sm p-0 text-muted pencil-btn d-none"
            data-level="Deliverable"
            data-id="@deliverable.Id"
            aria-label="Edit @deliverable.NamaDeliverable">
        <i class="bi bi-pencil"></i>
    </button>
</td>
```

**Replace with (no d-none on trash-btn for Deliverables):**
```cshtml
<td class="align-middle text-end pe-2">
    <button type="button"
            class="btn btn-link btn-sm p-0 text-muted pencil-btn d-none me-1"
            data-level="Deliverable"
            data-id="@deliverable.Id"
            aria-label="Edit @deliverable.NamaDeliverable">
        <i class="bi bi-pencil"></i>
    </button>
    <button type="button"
            class="btn btn-link btn-sm p-0 text-danger trash-btn"
            data-level="Deliverable"
            data-id="@deliverable.Id"
            aria-label="Delete @deliverable.NamaDeliverable">
        <i class="bi bi-trash"></i>
    </button>
</td>
```

No JavaScript changes in this file. All JS lives in Index.cshtml per the established Phase 35 pattern.
  </action>
  <verify>
Read `Views/ProtonCatalog/_CatalogTree.cshtml` and confirm:
- Three occurrences of `class="btn btn-link btn-sm p-0 text-danger trash-btn` exist (one per level)
- Kompetensi and SubKompetensi trash buttons have `d-none` in their class list
- Deliverable trash button does NOT have `d-none`
- Each trash button has matching `data-level` and `data-id` attributes
- `bi-trash` icon is present in each trash button
  </verify>
  <done>
`_CatalogTree.cshtml` has trash icon buttons on all three item levels. Kompetensi and SubKompetensi trash buttons are `d-none` by default. Deliverable trash buttons are always visible. All have `data-level` and `data-id` matching the pencil-btn on the same row.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add #deleteModal and initDeleteGuards() to Index.cshtml</name>
  <files>Views/ProtonCatalog/Index.cshtml</files>
  <action>
Two changes to Index.cshtml:

**A. Add the shared #deleteModal HTML** — place it after the existing `<!-- Add Track Modal -->` block, before the `@section Scripts` block.

```html
<!-- Delete Catalog Item Modal -->
<div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deleteModalLabel">Delete Catalog Item</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Loading state -->
                <div id="deleteModalLoading" class="text-center py-3">
                    <div class="spinner-border spinner-border-sm text-secondary me-2" role="status"></div>
                    <span class="text-muted">Loading impact...</span>
                </div>
                <!-- Content state (populated by JS) -->
                <div id="deleteModalContent" class="d-none"></div>
                <!-- Error state -->
                <div id="deleteModalError" class="d-none"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger d-none" id="deleteConfirmBtn">Yes, Delete</button>
            </div>
        </div>
    </div>
</div>
```

**B. Add initDeleteGuards() function** inside the `@section Scripts { <script> ... </script> }` block, after the closing brace of `initCatalogTree()` and before the `document.addEventListener('DOMContentLoaded', ...)` call.

The function:
1. Extends the existing collapse event listeners in initCatalogTree() to show/hide `.trash-btn.d-none` alongside `.pencil-btn.d-none` — by adding a new listener pass on `[data-bs-toggle="collapse"]` buttons inside `#treeContainer`
2. Wires `.trash-btn` click handlers to fetch GetDeleteImpact and open #deleteModal
3. Wires `#deleteConfirmBtn` click to POST DeleteCatalogItem

```js
function initDeleteGuards() {
    // Extend collapse events to also show/hide trash-btn (alongside pencil-btn, same pattern)
    document.querySelectorAll('#treeContainer [data-bs-toggle="collapse"]').forEach(function (btn) {
        var row = btn.closest('tr');
        if (!row) return;
        var trash = row.querySelector('.trash-btn');
        if (!trash) return;
        var targetId = btn.getAttribute('data-bs-target').replace('#', '');
        var target = document.getElementById(targetId);
        if (!target) return;
        target.addEventListener('show.bs.collapse', function () { trash.classList.remove('d-none'); });
        target.addEventListener('hide.bs.collapse', function () { trash.classList.add('d-none'); });
    });

    // Wire trash-btn clicks
    document.querySelectorAll('#treeContainer .trash-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
            var level = btn.dataset.level;
            var itemId = btn.dataset.id;

            // Store pending delete info on modal element for the confirm button
            var modalEl = document.getElementById('deleteModal');
            modalEl.dataset.pendingLevel = level;
            modalEl.dataset.pendingItemId = itemId;

            // Reset modal to loading state
            document.getElementById('deleteModalLoading').classList.remove('d-none');
            document.getElementById('deleteModalContent').classList.add('d-none');
            document.getElementById('deleteModalContent').innerHTML = '';
            document.getElementById('deleteModalError').classList.add('d-none');
            document.getElementById('deleteModalError').innerHTML = '';
            document.getElementById('deleteConfirmBtn').classList.add('d-none');
            document.getElementById('deleteConfirmBtn').disabled = false;
            document.getElementById('deleteConfirmBtn').innerHTML = 'Yes, Delete';

            // Show modal
            bootstrap.Modal.getOrCreateInstance(modalEl).show();

            // Fetch impact
            fetch('/ProtonCatalog/GetDeleteImpact?level=' + encodeURIComponent(level) + '&itemId=' + encodeURIComponent(itemId))
                .then(function (r) { return r.json(); })
                .then(function (result) {
                    document.getElementById('deleteModalLoading').classList.add('d-none');
                    if (!result.success) {
                        showDeleteError(result.error || 'Gagal memuat data.');
                        return;
                    }

                    // Build modal content
                    var content = document.getElementById('deleteModalContent');
                    var html = '<p>Delete <strong>' + escapeHtml(result.itemName) + '</strong>?</p>';

                    if (level === 'Kompetensi') {
                        html += '<ul class="mb-2">';
                        html += '<li>' + result.subKompetensiCount + ' SubKompetensi will be deleted</li>';
                        html += '<li>' + result.deliverableCount + ' Deliverables will be deleted</li>';
                        html += '</ul>';
                    } else if (level === 'SubKompetensi') {
                        html += '<ul class="mb-2">';
                        html += '<li>' + result.deliverableCount + ' Deliverables will be deleted</li>';
                        html += '</ul>';
                    }

                    if (result.coacheeCount === 0) {
                        html += '<div class="alert alert-info mb-0 py-2"><i class="bi bi-info-circle me-1"></i>No active coachees affected.</div>';
                    } else {
                        html += '<div class="alert alert-warning mb-0 py-2"><i class="bi bi-exclamation-triangle me-1"></i>' + result.coacheeCount + ' active coachee(s) have progress on this item or its children.</div>';
                    }

                    content.innerHTML = html;
                    content.classList.remove('d-none');
                    document.getElementById('deleteConfirmBtn').classList.remove('d-none');
                })
                .catch(function () {
                    document.getElementById('deleteModalLoading').classList.add('d-none');
                    showDeleteError('Terjadi kesalahan. Coba lagi.');
                });
        });
    });

    // Wire confirm button (single listener — replaces any prior listener by re-cloning the button)
    var confirmBtn = document.getElementById('deleteConfirmBtn');
    var freshBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(freshBtn, confirmBtn);
    freshBtn.addEventListener('click', function () {
        var modalEl = document.getElementById('deleteModal');
        var level = modalEl.dataset.pendingLevel;
        var itemId = modalEl.dataset.pendingItemId;

        freshBtn.disabled = true;
        freshBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status"></span>Deleting...';

        postItem('/ProtonCatalog/DeleteCatalogItem', { level: level, itemId: itemId }, function () {
            bootstrap.Modal.getInstance(modalEl).hide();
            reloadTree();
        }, function (err) {
            freshBtn.disabled = false;
            freshBtn.innerHTML = 'Yes, Delete';
            showDeleteError(err);
        });
    });
}

function showDeleteError(msg) {
    var err = document.getElementById('deleteModalError');
    err.innerHTML = '<div class="alert alert-danger mb-0 py-2">' + escapeHtml(msg) + '</div>';
    err.classList.remove('d-none');
    // Keep confirm button hidden when error shown on impact load; re-enabled when shown on delete failure (handled by caller)
}

function escapeHtml(str) {
    var div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}
```

**C. Call initDeleteGuards() after initCatalogTree() wherever initCatalogTree() is called:**

There are three call sites for initCatalogTree() in Index.cshtml:
1. Inside `reloadTree()` after `container.innerHTML = html;` — add `initDeleteGuards();` on the next line
2. Inside `document.addEventListener('DOMContentLoaded', ...)` — add `initDeleteGuards();` after `initCatalogTree();`
3. Inside `onTrackChanged()` after `initCatalogTree();` — add `initDeleteGuards();` after it

Also ensure the `#deleteConfirmBtn` listener re-wiring (the cloneNode approach) runs correctly on re-init. Because cloneNode removes old listeners from the button element itself, re-calling initDeleteGuards() after each reloadTree() is safe and correct.

**Important:** The `escapeHtml` and `showDeleteError` and `initDeleteGuards` functions are defined at the same script scope as `initCatalogTree`, `reloadTree`, `postItem`, etc. — they are accessible globally within the `@section Scripts` block.
  </action>
  <verify>
Run `dotnet build` from the project root and confirm zero `error CS` lines (Razor compilation included). Then verify by reading `Views/ProtonCatalog/Index.cshtml`:
- `id="deleteModal"` exists in the HTML section
- `id="deleteModalLoading"`, `id="deleteModalContent"`, `id="deleteModalError"`, `id="deleteConfirmBtn"` all exist inside the modal
- `function initDeleteGuards()` exists in the script section
- `initDeleteGuards()` is called in all three initCatalogTree() call sites (DOMContentLoaded, reloadTree, onTrackChanged)
- `function escapeHtml` exists
- `function showDeleteError` exists
  </verify>
  <done>
`dotnet build` compiles clean. Index.cshtml has the shared #deleteModal with three-state body divs. initDeleteGuards() is defined and called everywhere initCatalogTree() is called. escapeHtml() and showDeleteError() helpers are present.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Human verification — delete guard modal end-to-end</name>
  <files>Views/ProtonCatalog/_CatalogTree.cshtml, Views/ProtonCatalog/Index.cshtml, Controllers/ProtonCatalogController.cs</files>
  <action>
This is a human verification checkpoint. All implementation was completed in Tasks 1 and 2 (and Plan 01). This task confirms the end-to-end delete guard workflow functions correctly in the browser.
  </action>
  <what-built>
Phase 36 complete: GetDeleteImpact and DeleteCatalogItem endpoints in ProtonCatalogController (Plan 01); trash icons on all three tree levels in _CatalogTree.cshtml; shared #deleteModal with loading/content/error states and initDeleteGuards() wiring in Index.cshtml (Plan 02).
  </what-built>
  <how-to-verify>
Navigate to the Proton Catalog page (CDP Index > Proton Catalog card, or directly at /ProtonCatalog). Select a track from the dropdown.

**Trash icon visibility:**
1. Confirm no trash icons are visible on collapsed Kompetensi rows
2. Expand a Kompetensi row — confirm both pencil AND trash icons appear on the right of the Kompetensi row
3. Collapse the Kompetensi row — confirm both pencil and trash disappear
4. Re-expand the Kompetensi row — expand a SubKompetensi — confirm trash icon appears on the SubKompetensi row
5. Confirm Deliverable rows show trash icon (always visible, no expand needed beyond the parent SubKompetensi being open)

**Delete guard modal — Kompetensi:**
6. Click the trash icon on a Kompetensi row with at least one SubKompetensi and Deliverable
7. Confirm the modal opens immediately with a loading spinner visible
8. After the spinner, confirm modal body shows: item name in bold, bullet list with SubKompetensi count and Deliverable count, and a coachee line (info if 0, warning if > 0)
9. Confirm "Yes, Delete" button is visible in the modal footer

**Delete guard modal — confirm deletion:**
10. Click "Yes, Delete" — confirm the button becomes disabled with a spinner and text "Deleting..."
11. Confirm the modal closes automatically on success
12. Confirm the tree reloads and the deleted Kompetensi is no longer present

**Delete guard modal — Deliverable:**
13. Expand a SubKompetensi row with at least one Deliverable
14. Click the trash icon on a Deliverable row
15. Confirm modal opens, shows item name, and shows the coachee line (no children count bullets for Deliverables)
16. Click "Yes, Delete" — confirm deletion and tree reload

**Edge cases:**
17. Click Cancel in the modal (or click outside) — confirm no deletion occurs, tree unchanged
18. If possible to test: confirm an item with N > 0 active coachees shows the warning line (yellow/orange alert with count)
19. Confirm an item with 0 active coachees shows the info line (blue alert "No active coachees affected") and "Yes, Delete" is still clickable (no extra typing required)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build` from project root produces zero `error CS` lines
2. `Views/ProtonCatalog/_CatalogTree.cshtml` has `.trash-btn` buttons on all three levels; Kompetensi and SubKompetensi have `d-none`; Deliverable does not
3. Each trash button has `data-level` and `data-id` matching its pencil-btn sibling
4. `Views/ProtonCatalog/Index.cshtml` contains `id="deleteModal"` with three inner state divs: deleteModalLoading, deleteModalContent, deleteModalError
5. `function initDeleteGuards()` exists and wires collapse events for trash visibility, trash-btn click for impact fetch, and deleteConfirmBtn for delete POST
6. `initDeleteGuards()` is called alongside every `initCatalogTree()` call (DOMContentLoaded, reloadTree, onTrackChanged)
7. `escapeHtml()` helper is present (XSS protection for server-returned item names)
8. Human verification checkpoint passed (approved by user)
</verification>

<success_criteria>
Phase 36 requirements met — CAT-07 fully implemented:
- Success Criteria 1: HC/Admin clicks trash on Kompetensi — modal opens with item name and active coachee count
- Success Criteria 2: HC/Admin clicks "Yes, Delete" — item and all children deleted; tree refreshes without page reload
- Success Criteria 3: 0 coachees → modal still appears with info line; deletion still requires "Yes, Delete" click
- Success Criteria 4: Delete available on SubKompetensi and Deliverables with same guard and their own coachee counts
- Success Criteria 5: Cascade order enforced: ProtonDeliverableProgresses → ProtonDeliverableList → ProtonSubKompetensiList → ProtonKompetensiList (no FK violations)

Human verification checkpoint passed.
</success_criteria>

<output>
After completion, create `.planning/phases/36-delete-guards/36-02-SUMMARY.md`
</output>
