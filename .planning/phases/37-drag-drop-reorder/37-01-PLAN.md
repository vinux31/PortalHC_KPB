---
phase: 37-drag-drop-reorder
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/ProtonCatalogController.cs
autonomous: true

must_haves:
  truths:
    - "ReorderKompetensi POST accepts orderedIds int array and saves Urutan 1..N to ProtonKompetensiList"
    - "ReorderSubKompetensi POST accepts orderedIds int array and saves Urutan 1..N to ProtonSubKompetensiList"
    - "ReorderDeliverable POST accepts orderedIds int array and saves Urutan 1..N to ProtonDeliverableList"
    - "All three endpoints return JSON {success:true} on success and {success:false, error:string} on failure or unauthorized"
    - "RoleLevel > 2 returns {success:false, error:'Unauthorized'} not Forbid()"
  artifacts:
    - path: "Controllers/ProtonCatalogController.cs"
      provides: "ReorderKompetensi, ReorderSubKompetensi, ReorderDeliverable POST actions"
      contains: "ReorderKompetensi"
  key_links:
    - from: "Controllers/ProtonCatalogController.cs"
      to: "_context.ProtonKompetensiList"
      via: "Where + FirstOrDefault + Urutan assignment"
      pattern: "orderedIds\\.Contains"
    - from: "Controllers/ProtonCatalogController.cs"
      to: "_context.ProtonSubKompetensiList"
      via: "Where + FirstOrDefault + Urutan assignment"
      pattern: "ReorderSubKompetensi"
    - from: "Controllers/ProtonCatalogController.cs"
      to: "_context.ProtonDeliverableList"
      via: "Where + FirstOrDefault + Urutan assignment"
      pattern: "ReorderDeliverable"
---

<objective>
Add three POST actions to ProtonCatalogController that accept an ordered array of IDs and reassign Urutan 1..N for each catalog level.

Purpose: Provides the persistence layer that the drag-and-drop frontend will call on each drop event.
Output: ReorderKompetensi, ReorderSubKompetensi, and ReorderDeliverable endpoints returning JSON {success}.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Controllers/ProtonCatalogController.cs
@.planning/phases/37-drag-drop-reorder/37-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ReorderKompetensi, ReorderSubKompetensi, ReorderDeliverable to ProtonCatalogController</name>
  <files>Controllers/ProtonCatalogController.cs</files>
  <action>
Append three POST actions to ProtonCatalogController immediately after the DeleteCatalogItem action (before the closing brace of the class).

All three follow the same pattern as existing AJAX actions in this controller:
- Auth guard: user == null || user.RoleLevel > 2 → return Json({success:false, error:"Unauthorized"})
- Input guard: null/empty orderedIds → return Json({success:false, error:"Input tidak valid."})
- Load items by ID, reassign Urutan = i+1 in orderedIds order, SaveChangesAsync
- Return Json({success:true})

DbSet names (confirmed from ApplicationDbContext — use EXACT names as already used in this controller):
- ProtonKompetensiList (see existing AddKompetensi action)
- ProtonSubKompetensiList (see existing AddSubKompetensi action)
- ProtonDeliverableList (see existing AddDeliverable action)

Field names (confirmed from ProtonModels.cs): all three use `Urutan` (int).

Implement exactly:

```csharp
// POST: /ProtonCatalog/ReorderKompetensi
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> ReorderKompetensi(int[] orderedIds)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (orderedIds == null || orderedIds.Length == 0)
        return Json(new { success = false, error = "Input tidak valid." });

    var items = await _context.ProtonKompetensiList
        .Where(k => orderedIds.Contains(k.Id))
        .ToListAsync();

    for (int i = 0; i < orderedIds.Length; i++)
    {
        var item = items.FirstOrDefault(k => k.Id == orderedIds[i]);
        if (item != null) item.Urutan = i + 1;
    }

    await _context.SaveChangesAsync();
    return Json(new { success = true });
}

// POST: /ProtonCatalog/ReorderSubKompetensi
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> ReorderSubKompetensi(int[] orderedIds)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (orderedIds == null || orderedIds.Length == 0)
        return Json(new { success = false, error = "Input tidak valid." });

    var items = await _context.ProtonSubKompetensiList
        .Where(s => orderedIds.Contains(s.Id))
        .ToListAsync();

    for (int i = 0; i < orderedIds.Length; i++)
    {
        var item = items.FirstOrDefault(s => s.Id == orderedIds[i]);
        if (item != null) item.Urutan = i + 1;
    }

    await _context.SaveChangesAsync();
    return Json(new { success = true });
}

// POST: /ProtonCatalog/ReorderDeliverable
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> ReorderDeliverable(int[] orderedIds)
{
    var user = await _userManager.GetUserAsync(User);
    if (user == null || user.RoleLevel > 2)
        return Json(new { success = false, error = "Unauthorized" });

    if (orderedIds == null || orderedIds.Length == 0)
        return Json(new { success = false, error = "Input tidak valid." });

    var items = await _context.ProtonDeliverableList
        .Where(d => orderedIds.Contains(d.Id))
        .ToListAsync();

    for (int i = 0; i < orderedIds.Length; i++)
    {
        var item = items.FirstOrDefault(d => d.Id == orderedIds[i]);
        if (item != null) item.Urutan = i + 1;
    }

    await _context.SaveChangesAsync();
    return Json(new { success = true });
}
```

Insert these three actions before the final closing `}` of the class (after `DeleteCatalogItem`'s closing brace on line ~406).

No new using statements needed — all types already imported.
  </action>
  <verify>
Run: `dotnet build`
Build must succeed with 0 errors.
Confirm the three action method names exist: grep for "ReorderKompetensi", "ReorderSubKompetensi", "ReorderDeliverable" in Controllers/ProtonCatalogController.cs — all three must appear.
  </verify>
  <done>
`dotnet build` exits 0. All three Reorder* methods present in ProtonCatalogController.cs. Each method has [HttpPost], [ValidateAntiForgeryToken], auth guard, input guard, load-and-reassign-Urutan loop, and SaveChangesAsync.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds with 0 errors
- Controllers/ProtonCatalogController.cs contains ReorderKompetensi, ReorderSubKompetensi, ReorderDeliverable
- Each action: [HttpPost] + [ValidateAntiForgeryToken] + RoleLevel > 2 guard + orderedIds null check + Urutan i+1 loop + SaveChangesAsync
- Return shape matches: Json({success:true}) on success, Json({success:false, error:string}) on guard failures
</verification>

<success_criteria>
Three Reorder POST actions exist in ProtonCatalogController. `dotnet build` passes. The frontend plan (37-02) can call /ProtonCatalog/ReorderKompetensi, /ProtonCatalog/ReorderSubKompetensi, /ProtonCatalog/ReorderDeliverable and receive JSON {success:true/false}.
</success_criteria>

<output>
After completion, create `.planning/phases/37-drag-drop-reorder/37-01-SUMMARY.md`
</output>
