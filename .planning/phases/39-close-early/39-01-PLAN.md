---
phase: 39-close-early
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/CMPController.cs
autonomous: true

must_haves:
  truths:
    - "CloseEarly POST action exists in CMPController with [Authorize(Roles='Admin, HC')] and [ValidateAntiForgeryToken]"
    - "All sessions in the group receive ExamWindowCloseDate=DateTime.UtcNow (blocking new starts)"
    - "InProgress sessions (StartedAt != null && CompletedAt == null) are marked Status=Completed with score calculated from PackageUserResponse answers (package mode) or UserResponse answers (legacy mode)"
    - "NotStarted sessions are left unchanged except for ExamWindowCloseDate — Status and Score remain as-is"
    - "UserPackageAssignment.IsCompleted=true is set for each InProgress session scored in package mode"
    - "Competency levels are auto-updated for InProgress sessions where IsPassed=true (same logic as SubmitExam lines 2878-2921)"
    - "A single SaveChangesAsync() call at end atomically persists all changes"
    - "AuditLog entry with ActionType='CloseEarly' including count of InProgress sessions scored and total sessions locked"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "CloseEarly POST action"
      contains: "public async Task<IActionResult> CloseEarly"
  key_links:
    - from: "CloseEarly action"
      to: "PackageUserResponses table"
      via: "ToDictionaryAsync(r => r.PackageQuestionId, r => r.PackageOptionId)"
      pattern: "PackageUserResponses.*AssessmentSessionId.*session\\.Id"
    - from: "CloseEarly action"
      to: "UserPackageAssignments"
      via: "FirstOrDefaultAsync(a => a.AssessmentSessionId == session.Id)"
      pattern: "UserPackageAssignments.*FirstOrDefaultAsync"
    - from: "CloseEarly action"
      to: "AuditLogService"
      via: "_auditLog.LogAsync with ActionType='CloseEarly'"
      pattern: "LogAsync.*CloseEarly"
---

<objective>
Add CloseEarly POST action to CMPController. The action sets ExamWindowCloseDate=DateTime.UtcNow on all sessions in the group to block new starts, then for each InProgress session calculates a fair score from the worker's actual submitted answers (PackageUserResponse in package mode, UserResponse in legacy mode) using the same grading logic as SubmitExam. NotStarted sessions are left as-is. Competency levels are updated for passed sessions. Finishes with a single SaveChangesAsync and an audit log entry.

Purpose: HC can close an active assessment group with confidence that workers who already answered questions receive a score reflecting their effort, not Score=0.
Output: CloseEarly action in CMPController.cs, inserted after ForceCloseAll (~line 783).
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-close-early/39-RESEARCH.md
@Controllers/CMPController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CloseEarly POST action to CMPController after ForceCloseAll (~line 783)</name>
  <files>Controllers/CMPController.cs</files>
  <action>
Insert the following CloseEarly action immediately after the closing brace of ForceCloseAll at line 782 (before the "// --- RESHUFFLE PACKAGE" comment at line 784). The action must:

**Signature and authorization:**
```csharp
[HttpPost]
[Authorize(Roles = "Admin, HC")]
[ValidateAntiForgeryToken]
public async Task<IActionResult> CloseEarly(string title, string category, DateTime scheduleDate)
```

**Step 1 — Load all sibling sessions (same pattern as ForceCloseAll lines 747-752):**
```csharp
var allSessions = await _context.AssessmentSessions
    .Where(a => a.Title == title
             && a.Category == category
             && a.Schedule.Date == scheduleDate.Date)
    .ToListAsync();

if (!allSessions.Any())
{
    TempData["Error"] = "Assessment group not found.";
    return RedirectToAction("AssessmentMonitoringDetail", new { title, category, scheduleDate });
}
```

**Step 2 — Detect package mode (same pattern as AssessmentMonitoringDetail lines 405-408):**
```csharp
var siblingIds = allSessions.Select(s => s.Id).ToList();
var packageCount = await _context.AssessmentPackages
    .CountAsync(p => siblingIds.Contains(p.AssessmentSessionId));
var isPackageMode = packageCount > 0;
```

**Step 3 — For package mode: preload all packages + questions + options + assignments in bulk (avoid N+1 queries):**
```csharp
// For package mode: load all UserPackageAssignments and packages up front
Dictionary<int, UserPackageAssignment> sessionAssignmentMap = new();
Dictionary<int, AssessmentPackage> packageMap = new();

if (isPackageMode)
{
    var assignments = await _context.UserPackageAssignments
        .Where(a => siblingIds.Contains(a.AssessmentSessionId))
        .ToListAsync();
    foreach (var a in assignments)
        sessionAssignmentMap[a.AssessmentSessionId] = a;

    var packageIds = assignments.Select(a => a.AssessmentPackageId).Distinct().ToList();
    var packages = await _context.AssessmentPackages
        .Include(p => p.Questions)
            .ThenInclude(q => q.Options)
        .Where(p => packageIds.Contains(p.Id))
        .ToListAsync();
    foreach (var p in packages)
        packageMap[p.Id] = p;
}
```

**Step 4 — For legacy mode: preload questions + options for the group's sibling that has questions (same pattern as SubmitExam lines 2931-2945):**
```csharp
List<AssessmentQuestion> legacyQuestions = new();
if (!isPackageMode)
{
    var siblingWithQuestions = await _context.AssessmentSessions
        .Include(a => a.Questions)
            .ThenInclude(q => q.Options)
        .Where(a => siblingIds.Contains(a.Id) && a.Questions.Any())
        .FirstOrDefaultAsync();
    legacyQuestions = siblingWithQuestions?.Questions?.ToList() ?? new();
}
```

**Step 5 — Loop over all sessions, set ExamWindowCloseDate, score InProgress sessions:**
```csharp
int inProgressCount = 0;

foreach (var session in allSessions)
{
    // Always lock out future starts
    session.ExamWindowCloseDate = DateTime.UtcNow;
    session.UpdatedAt = DateTime.UtcNow;

    bool isInProgress = session.StartedAt != null && session.CompletedAt == null && session.Score == null;
    if (!isInProgress) continue;

    inProgressCount++;

    if (isPackageMode)
    {
        // Package path: score from PackageUserResponse records
        if (!sessionAssignmentMap.TryGetValue(session.Id, out var assignment)) continue;
        if (!packageMap.TryGetValue(assignment.AssessmentPackageId, out var pkg)) continue;

        // Load existing answers for this session as a dictionary questionId -> optionId
        var responses = await _context.PackageUserResponses
            .Where(r => r.AssessmentSessionId == session.Id)
            .ToDictionaryAsync(r => r.PackageQuestionId, r => r.PackageOptionId);

        int totalScore = 0;
        int maxScore = pkg.Questions.Sum(q => q.ScoreValue); // use Sum, not Count*10 (Pitfall 6)

        foreach (var q in pkg.Questions)
        {
            if (responses.TryGetValue(q.Id, out var optId) && optId.HasValue)
            {
                var selectedOption = q.Options.FirstOrDefault(o => o.Id == optId.Value);
                if (selectedOption != null && selectedOption.IsCorrect)
                    totalScore += q.ScoreValue;
            }
            // No answer = no points (Pitfall 5 handled)
        }

        int finalPercentage = maxScore > 0 ? (int)((double)totalScore / maxScore * 100) : 0;

        session.Score = finalPercentage;
        session.Status = "Completed";
        session.Progress = 100;
        session.IsPassed = finalPercentage >= session.PassPercentage;
        session.CompletedAt = DateTime.UtcNow;
        assignment.IsCompleted = true;

        // Competency update for passed sessions (parity with SubmitExam lines 2878-2921)
        if (session.IsPassed == true)
        {
            var mappedCompetencies = await _context.AssessmentCompetencyMaps
                .Include(m => m.KkjMatrixItem)
                .Where(m => m.AssessmentCategory == session.Category &&
                            (m.TitlePattern == null || session.Title.Contains(m.TitlePattern)))
                .ToListAsync();

            if (mappedCompetencies.Any())
            {
                var sessionUser = await _context.Users.FindAsync(session.UserId);
                foreach (var mapping in mappedCompetencies)
                {
                    if (mapping.MinimumScoreRequired.HasValue && session.Score < mapping.MinimumScoreRequired.Value)
                        continue;

                    var existingLevel = await _context.UserCompetencyLevels
                        .FirstOrDefaultAsync(c => c.UserId == session.UserId &&
                                                  c.KkjMatrixItemId == mapping.KkjMatrixItemId);
                    if (existingLevel == null)
                    {
                        int targetLevel = PositionTargetHelper.GetTargetLevel(mapping.KkjMatrixItem!, sessionUser?.Position);
                        _context.UserCompetencyLevels.Add(new UserCompetencyLevel
                        {
                            UserId = session.UserId,
                            KkjMatrixItemId = mapping.KkjMatrixItemId,
                            CurrentLevel = mapping.LevelGranted,
                            TargetLevel = targetLevel,
                            Source = "Assessment",
                            AssessmentSessionId = session.Id,
                            AchievedAt = DateTime.UtcNow
                        });
                    }
                    else if (mapping.LevelGranted > existingLevel.CurrentLevel)
                    {
                        existingLevel.CurrentLevel = mapping.LevelGranted;
                        existingLevel.Source = "Assessment";
                        existingLevel.AssessmentSessionId = session.Id;
                        existingLevel.UpdatedAt = DateTime.UtcNow;
                    }
                }
            }
        }
    }
    else
    {
        // Legacy path: score from UserResponse records (reuse SubmitExam legacy grading logic)
        // Load answers for this session
        var userResponses = await _context.UserResponses
            .Where(r => r.AssessmentSessionId == session.Id)
            .ToDictionaryAsync(r => r.AssessmentQuestionId, r => r.SelectedOptionId);

        int totalScore = 0;
        int maxScore = 0;

        foreach (var question in legacyQuestions)
        {
            maxScore += question.ScoreValue;
            if (userResponses.TryGetValue(question.Id, out var selectedOptionId) && selectedOptionId.HasValue)
            {
                var selectedOption = question.Options.FirstOrDefault(o => o.Id == selectedOptionId.Value);
                if (selectedOption != null && selectedOption.IsCorrect)
                    totalScore += question.ScoreValue;
            }
        }

        int finalPercentage = maxScore > 0 ? (int)((double)totalScore / maxScore * 100) : 0;

        session.Score = finalPercentage;
        session.Status = "Completed";
        session.Progress = 100;
        session.IsPassed = finalPercentage >= session.PassPercentage;
        session.CompletedAt = DateTime.UtcNow;

        // Competency update for legacy passed sessions
        if (session.IsPassed == true)
        {
            var mappedCompetencies = await _context.AssessmentCompetencyMaps
                .Include(m => m.KkjMatrixItem)
                .Where(m => m.AssessmentCategory == session.Category &&
                            (m.TitlePattern == null || session.Title.Contains(m.TitlePattern)))
                .ToListAsync();

            if (mappedCompetencies.Any())
            {
                var sessionUser = await _context.Users.FindAsync(session.UserId);
                foreach (var mapping in mappedCompetencies)
                {
                    if (mapping.MinimumScoreRequired.HasValue && session.Score < mapping.MinimumScoreRequired.Value)
                        continue;

                    var existingLevel = await _context.UserCompetencyLevels
                        .FirstOrDefaultAsync(c => c.UserId == session.UserId &&
                                                  c.KkjMatrixItemId == mapping.KkjMatrixItemId);
                    if (existingLevel == null)
                    {
                        int targetLevel = PositionTargetHelper.GetTargetLevel(mapping.KkjMatrixItem!, sessionUser?.Position);
                        _context.UserCompetencyLevels.Add(new UserCompetencyLevel
                        {
                            UserId = session.UserId,
                            KkjMatrixItemId = mapping.KkjMatrixItemId,
                            CurrentLevel = mapping.LevelGranted,
                            TargetLevel = targetLevel,
                            Source = "Assessment",
                            AssessmentSessionId = session.Id,
                            AchievedAt = DateTime.UtcNow
                        });
                    }
                    else if (mapping.LevelGranted > existingLevel.CurrentLevel)
                    {
                        existingLevel.CurrentLevel = mapping.LevelGranted;
                        existingLevel.Source = "Assessment";
                        existingLevel.AssessmentSessionId = session.Id;
                        existingLevel.UpdatedAt = DateTime.UtcNow;
                    }
                }
            }
        }
    }
}
```

**Step 6 — Single SaveChangesAsync + audit log + redirect:**
```csharp
await _context.SaveChangesAsync();

var actor = await _userManager.GetUserAsync(User);
var actorName = $"{actor?.NIP ?? "?"} - {actor?.FullName ?? "Unknown"}";
await _auditLog.LogAsync(
    actor?.Id ?? "",
    actorName,
    "CloseEarly",
    $"Closed early assessment group '{title}' (Category: {category}, Date: {scheduleDate:yyyy-MM-dd}) — {inProgressCount} session(s) scored from answers, {allSessions.Count} total session(s) locked",
    null,
    "AssessmentSession");

TempData["Success"] = $"Assessment group ditutup lebih awal. {inProgressCount} sesi diberi skor berdasarkan jawaban yang sudah dikerjakan.";
return RedirectToAction("AssessmentMonitoringDetail", new { title, category, scheduleDate });
```

**CRITICAL:** Do NOT write new PackageUserResponse records (SubmitExam does, but CloseEarly reads existing ones). The comment in the loop already clarifies this.

**CRITICAL:** The `isInProgress` check must use `session.StartedAt != null && session.CompletedAt == null && session.Score == null` (not just Status == "InProgress") — the 4-state display logic uses these timestamps as the source of truth (verified from CMPController lines 438-446).

**NOTE on maxScore:** Use `pkg.Questions.Sum(q => q.ScoreValue)` not `pkg.Questions.Count * 10` to be safe against questions with non-standard ScoreValue (Pitfall 6 from RESEARCH.md).
  </action>
  <verify>
Run `dotnet build` in the project root. Output must show "Build succeeded" with 0 errors. Check that the CloseEarly action appears in the compiled output by running:
```
grep -n "CloseEarly" Controllers/CMPController.cs
```
Expected: lines showing `[HttpPost]` action, `LogAsync.*CloseEarly`, and `RedirectToAction.*AssessmentMonitoringDetail`.
  </verify>
  <done>
`dotnet build` succeeds with 0 errors. `grep -n "CloseEarly" Controllers/CMPController.cs` returns 3+ matches including the action declaration, the audit log call, and the TempData success message. The action is positioned after the ForceCloseAll closing brace (after line 782).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` — 0 errors, 0 warnings related to CloseEarly code
2. `grep -n "CloseEarly\|isInProgress\|ExamWindowCloseDate\|inProgressCount" Controllers/CMPController.cs` — shows all key variables in the new action
3. `grep -n "PackageUserResponses.Add\|UserResponses.Add" Controllers/CMPController.cs` — CloseEarly must NOT appear in matches (it reads responses, never adds them)
4. `grep -c "SaveChangesAsync" Controllers/CMPController.cs` — should be consistent with before (CloseEarly adds exactly 1 new call)
</verification>

<success_criteria>
- CloseEarly POST action inserted after ForceCloseAll (line 782) in CMPController.cs
- Action detects package vs legacy mode using same pattern as AssessmentMonitoringDetail (lines 405-408)
- InProgress detection uses StartedAt != null AND CompletedAt == null AND Score == null
- Package mode: answers loaded from PackageUserResponses as dictionary (not N+1 per question)
- Package mode: maxScore uses Sum(q.ScoreValue), not Count * 10
- Package mode: UserPackageAssignment.IsCompleted set to true
- Legacy mode: answers loaded from UserResponses as dictionary
- Both modes: competency update block runs if IsPassed == true
- ExamWindowCloseDate set on ALL sessions (not just InProgress)
- Single SaveChangesAsync at end (atomicity)
- AuditLog entry with ActionType="CloseEarly"
- dotnet build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/39-close-early/39-01-SUMMARY.md`
</output>
