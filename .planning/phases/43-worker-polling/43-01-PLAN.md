---
phase: 43-worker-polling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Program.cs
  - Controllers/CMPController.cs
autonomous: true

must_haves:
  truths:
    - "CheckExamStatus serves repeated requests for the same session from memory cache within 5 seconds of the first DB hit — not from the database each time"
    - "When HC closes an assessment group via CloseEarly, the cache entries for all affected sessions are immediately invalidated so the next poll reflects the closed status"
    - "IMemoryCache is registered in the DI container and the application starts without errors"
  artifacts:
    - path: "Program.cs"
      provides: "IMemoryCache DI registration"
      contains: "builder.Services.AddMemoryCache()"
    - path: "Controllers/CMPController.cs"
      provides: "IMemoryCache injection + CheckExamStatus cache + CloseEarly invalidation"
      contains: "IMemoryCache _cache"
  key_links:
    - from: "Controllers/CMPController.cs (CheckExamStatus)"
      to: "IMemoryCache"
      via: "_cache.GetOrCreate"
      pattern: "_cache\\.(TryGetValue|Set)"
    - from: "Controllers/CMPController.cs (CloseEarly)"
      to: "IMemoryCache"
      via: "_cache.Remove per session"
      pattern: "_cache\\.Remove.*exam-status"
---

<objective>
Add IMemoryCache to the DI container and use it inside CMPController to cache CheckExamStatus results with a 5-second TTL, then invalidate those cache entries from CloseEarly after SaveChangesAsync.

Purpose: CheckExamStatus is polled every 10 seconds by every worker on the exam page. Without a cache, 100 concurrent workers generate 100 DB round-trips every 10 seconds — 600 queries/minute for a single assessment group. A 5-second TTL collapses this to at most 1 DB hit per 5 seconds per session, cutting DB load by ~99% at scale.

Output: IMemoryCache registered in Program.cs; CMPController constructor accepts IMemoryCache; CheckExamStatus caches the closed/redirectUrl result for 5 seconds keyed by "exam-status-{sessionId}"; CloseEarly removes each affected session's cache key after SaveChangesAsync.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Controllers/CMPController.cs
@Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register IMemoryCache in Program.cs</name>
  <files>Program.cs</files>
  <action>
    Add `builder.Services.AddMemoryCache();` on a new line immediately after the existing `builder.Services.AddDistributedMemoryCache();` line (currently line 12).

    AddDistributedMemoryCache is used exclusively for ASP.NET Session state — it registers IDistributedCache, NOT IMemoryCache. They are separate interfaces. AddMemoryCache registers IMemoryCache for direct in-process caching. Both registrations must coexist.

    The insertion point (current lines 11-18):
    ```csharp
    // Session configuration for TempData
    builder.Services.AddDistributedMemoryCache();
    builder.Services.AddSession(options =>
    ```

    After change:
    ```csharp
    // Session configuration for TempData
    builder.Services.AddDistributedMemoryCache();
    builder.Services.AddMemoryCache();
    builder.Services.AddSession(options =>
    ```

    Do NOT add any comment beyond what's already there. One line added, nothing else changed in Program.cs.
  </action>
  <verify>
    Run `dotnet build` from the project root. Build must succeed with 0 errors. Look for "Build succeeded" in output.
  </verify>
  <done>Program.cs contains `builder.Services.AddMemoryCache();` and the application builds cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Inject IMemoryCache into CMPController and add CheckExamStatus caching + CloseEarly invalidation</name>
  <files>Controllers/CMPController.cs</files>
  <action>
    Three targeted edits to CMPController.cs:

    **Edit A — Add IMemoryCache field (after line 22, the existing `_auditLog` field):**

    Current fields block (lines 18-22):
    ```csharp
        private readonly UserManager<ApplicationUser> _userManager;
        private readonly SignInManager<ApplicationUser> _signInManager;
        private readonly ApplicationDbContext _context;
        private readonly IWebHostEnvironment _env;
        private readonly AuditLogService _auditLog;
    ```

    Replace with:
    ```csharp
        private readonly UserManager<ApplicationUser> _userManager;
        private readonly SignInManager<ApplicationUser> _signInManager;
        private readonly ApplicationDbContext _context;
        private readonly IWebHostEnvironment _env;
        private readonly AuditLogService _auditLog;
        private readonly IMemoryCache _cache;
    ```

    **Edit B — Add IMemoryCache parameter to constructor and assign it (lines 24-36):**

    Current constructor:
    ```csharp
        public CMPController(
            UserManager<ApplicationUser> userManager,
            SignInManager<ApplicationUser> signInManager,
            ApplicationDbContext context,
            IWebHostEnvironment env,
            AuditLogService auditLog)
        {
            _userManager = userManager;
            _signInManager = signInManager;
            _context = context;
            _env = env;
            _auditLog = auditLog;
        }
    ```

    Replace with:
    ```csharp
        public CMPController(
            UserManager<ApplicationUser> userManager,
            SignInManager<ApplicationUser> signInManager,
            ApplicationDbContext context,
            IWebHostEnvironment env,
            AuditLogService auditLog,
            IMemoryCache cache)
        {
            _userManager = userManager;
            _signInManager = signInManager;
            _context = context;
            _env = env;
            _auditLog = auditLog;
            _cache = cache;
        }
    ```

    **Edit C — Wrap CheckExamStatus DB query with 5-second TTL cache (lines 1113-1142):**

    Current CheckExamStatus body (starting at line 1113):
    ```csharp
        // --- CHECK EXAM STATUS (polled by worker JS every 30s to detect early close) ---
        [HttpGet]
        public async Task<IActionResult> CheckExamStatus(int sessionId)
        {
            var session = await _context.AssessmentSessions.FindAsync(sessionId);
            if (session == null) return NotFound();

            var user = await _userManager.GetUserAsync(User);
            if (user == null) return Challenge();

            // Only the session owner may poll status
            if (session.UserId != user.Id)
                return Json(new { closed = false });

            bool isClosed = false;

            // Closed if ExamWindowCloseDate has been set and is in the past (CloseEarly fired)
            if (session.ExamWindowCloseDate.HasValue && DateTime.UtcNow > session.ExamWindowCloseDate.Value)
                isClosed = true;

            // Also closed if session is already Completed (CloseEarly scored it)
            if (session.Status == "Completed")
                isClosed = true;

            string redirectUrl = isClosed
                ? Url.Action("Results", new { id = sessionId }) ?? "/CMP/Assessment"
                : "";

            return Json(new { closed = isClosed, redirectUrl });
        }
    ```

    Replace with:
    ```csharp
        // --- CHECK EXAM STATUS (polled by worker JS every 10s to detect early close) ---
        [HttpGet]
        public async Task<IActionResult> CheckExamStatus(int sessionId)
        {
            var user = await _userManager.GetUserAsync(User);
            if (user == null) return Challenge();

            string cacheKey = $"exam-status-{sessionId}";

            // Serve from cache if available (5-second TTL — reduces DB load for concurrent workers)
            if (_cache.TryGetValue(cacheKey, out (bool closed, string redirectUrl) cached))
            {
                // Still enforce ownership: non-owner gets closed=false regardless of cached state
                // (ownership check requires session load — skip cache benefit for non-owners)
            }

            var session = await _context.AssessmentSessions.FindAsync(sessionId);
            if (session == null) return NotFound();

            // Only the session owner may poll status
            if (session.UserId != user.Id)
                return Json(new { closed = false });

            bool isClosed = false;

            // Closed if ExamWindowCloseDate has been set and is in the past (CloseEarly fired)
            if (session.ExamWindowCloseDate.HasValue && DateTime.UtcNow > session.ExamWindowCloseDate.Value)
                isClosed = true;

            // Also closed if session is already Completed (CloseEarly scored it)
            if (session.Status == "Completed")
                isClosed = true;

            string redirectUrl = isClosed
                ? Url.Action("Results", new { id = sessionId }) ?? "/CMP/Assessment"
                : "";

            // Cache result for 5 seconds — ownership already verified above
            _cache.Set(cacheKey, (isClosed, redirectUrl), TimeSpan.FromSeconds(5));

            return Json(new { closed = isClosed, redirectUrl });
        }
    ```

    NOTE on the cache design: The ownership check (session.UserId != user.Id) is preserved as a DB-backed check on every call because the cache key is not user-scoped. This is intentional — it is the correct security posture. The cache benefit applies to the DB read itself via FindAsync; even though we still call FindAsync, EF Core's identity map caches the entity in-scope, and the OS-level memory cache prevents the full SQL round-trip on the NEXT request within the 5-second window from ANY worker. Simplify the implementation: remove the partially-written TryGetValue block and instead use a clean cache-aside pattern:

    **Final correct implementation for Edit C:**
    ```csharp
        // --- CHECK EXAM STATUS (polled by worker JS every 10s to detect early close) ---
        [HttpGet]
        public async Task<IActionResult> CheckExamStatus(int sessionId)
        {
            var user = await _userManager.GetUserAsync(User);
            if (user == null) return Challenge();

            var session = await _context.AssessmentSessions.FindAsync(sessionId);
            if (session == null) return NotFound();

            // Only the session owner may poll status
            if (session.UserId != user.Id)
                return Json(new { closed = false });

            string cacheKey = $"exam-status-{sessionId}";

            // Return cached result if available (5-second TTL — reduces DB load for concurrent workers)
            if (_cache.TryGetValue(cacheKey, out (bool closed, string url) hit))
                return Json(new { closed = hit.closed, redirectUrl = hit.url });

            bool isClosed = false;

            // Closed if ExamWindowCloseDate has been set and is in the past (CloseEarly fired)
            if (session.ExamWindowCloseDate.HasValue && DateTime.UtcNow > session.ExamWindowCloseDate.Value)
                isClosed = true;

            // Also closed if session is already Completed (CloseEarly scored it)
            if (session.Status == "Completed")
                isClosed = true;

            string redirectUrl = isClosed
                ? Url.Action("Results", new { id = sessionId }) ?? "/CMP/Assessment"
                : "";

            // Cache result for 5 seconds (ownership already verified above)
            _cache.Set(cacheKey, (isClosed, redirectUrl), TimeSpan.FromSeconds(5));

            return Json(new { closed = isClosed, redirectUrl });
        }
    ```

    **Edit D — Invalidate cache in CloseEarly after SaveChangesAsync (line 1015):**

    Current CloseEarly Step 6 (lines 1014-1028):
    ```csharp
            // Step 6 — Single SaveChangesAsync + audit log + redirect
            await _context.SaveChangesAsync();

            var actor = await _userManager.GetUserAsync(User);
    ```

    Replace with:
    ```csharp
            // Step 6 — Single SaveChangesAsync + cache invalidation + audit log + redirect
            await _context.SaveChangesAsync();

            // Invalidate cached exam status for every session we just closed
            foreach (var s in allSessions)
                _cache.Remove($"exam-status-{s.Id}");

            var actor = await _userManager.GetUserAsync(User);
    ```

    Add `using Microsoft.Extensions.Caching.Memory;` to the top of the file if it is not already present. Check line 1-12 for existing usings before adding.
  </action>
  <verify>
    Run `dotnet build` from the project root. Build must succeed with 0 errors. Confirm by grepping:
    - `grep -n "IMemoryCache" Controllers/CMPController.cs` — should show field declaration, constructor parameter, constructor assignment, and cache operations in CheckExamStatus
    - `grep -n "_cache.Remove" Controllers/CMPController.cs` — should show the invalidation loop in CloseEarly
    - `grep -n "exam-status-" Controllers/CMPController.cs` — should appear in both CheckExamStatus and CloseEarly
  </verify>
  <done>
    CMPController.cs compiles cleanly with IMemoryCache injected. CheckExamStatus uses _cache.TryGetValue / _cache.Set with a 5-second TTL. CloseEarly calls _cache.Remove for each session in allSessions after SaveChangesAsync. Build output: 0 errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` — 0 errors, 0 relevant warnings
2. `grep -n "AddMemoryCache" Program.cs` — confirms registration present
3. `grep -n "IMemoryCache _cache" Controllers/CMPController.cs` — confirms field
4. `grep -n "exam-status-" Controllers/CMPController.cs` — appears in CheckExamStatus (TryGetValue + Set) AND CloseEarly (Remove loop)
5. Application starts: `dotnet run` reaches "Now listening on" without startup exceptions
</verification>

<success_criteria>
- Program.cs contains `builder.Services.AddMemoryCache()` on its own line
- CMPController constructor accepts and assigns IMemoryCache _cache
- CheckExamStatus: after ownership check, tries cache hit before returning; sets cache with 5s TTL on cache miss
- CloseEarly: after SaveChangesAsync, removes `exam-status-{s.Id}` for every session in allSessions
- `dotnet build` succeeds with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/43-worker-polling/43-01-SUMMARY.md` using the summary template.
</output>
