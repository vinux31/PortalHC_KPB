---
phase: 44-real-time-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/CMPController.cs
autonomous: true

must_haves:
  truths:
    - "GET /CMP/GetMonitoringProgress returns a JSON array when called with valid title/category/scheduleDate"
    - "Each DTO contains sessionId, status, progress, totalQuestions, score, result, remainingSeconds, completedAt"
    - "progress reflects the actual count of answered questions (PackageUserResponse rows for package mode, UserResponse rows for legacy mode)"
    - "remainingSeconds is non-null only for InProgress sessions; null for Not started, Completed, Abandoned"
    - "result is 'Pass' when IsPassed=true, 'Fail' when IsPassed=false, null when IsPassed=null"
    - "Endpoint returns 401/403 for non-HC/Admin callers; no antiforgery token required"
  artifacts:
    - path: "Controllers/CMPController.cs"
      provides: "GetMonitoringProgress action"
      contains: "public async Task<IActionResult> GetMonitoringProgress"
  key_links:
    - from: "Controllers/CMPController.cs GetMonitoringProgress"
      to: "_context.PackageUserResponses"
      via: "GROUP BY AssessmentSessionId (single query, not N+1)"
      pattern: "GroupBy\\(p => p\\.AssessmentSessionId\\)"
    - from: "Controllers/CMPController.cs GetMonitoringProgress"
      to: "_context.UserResponses"
      via: "GROUP BY AssessmentSessionId for legacy mode"
      pattern: "GroupBy\\(r => r\\.AssessmentSessionId\\)"
---

<objective>
Add the `GetMonitoringProgress` JSON endpoint to CMPController so the frontend polling introduced in Plan 02 has a data source.

Purpose: Provide per-session status snapshots (progress, score, time remaining) for all sessions in a monitoring group, enabling the HC dashboard to auto-update without page refresh.
Output: One new `[HttpGet]` action in `Controllers/CMPController.cs` — no new files, no migration.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Models/AssessmentMonitoringViewModel.cs
@Controllers/CMPController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GetMonitoringProgress endpoint to CMPController</name>
  <files>Controllers/CMPController.cs</files>
  <action>
Insert a new action immediately after the `AssessmentMonitoringDetail` action (around line 487, before `// --- RESET ASSESSMENT ---`).

```csharp
// --- GET MONITORING PROGRESS (polling endpoint for HC real-time monitoring) ---
[HttpGet]
[Authorize(Roles = "Admin, HC")]
public async Task<IActionResult> GetMonitoringProgress(string title, string category, DateTime scheduleDate)
{
    // Step 1: load sessions (same filter as AssessmentMonitoringDetail)
    var sessions = await _context.AssessmentSessions
        .Where(a => a.Title == title
                 && a.Category == category
                 && a.Schedule.Date == scheduleDate.Date)
        .ToListAsync();

    if (!sessions.Any())
        return Json(Array.Empty<object>());

    var siblingIds = sessions.Select(s => s.Id).ToList();

    // Step 2: detect package mode
    var packageCount = await _context.AssessmentPackages
        .CountAsync(p => siblingIds.Contains(p.AssessmentSessionId));
    var isPackageMode = packageCount > 0;

    // Step 3: build total question count map per session (reuse pattern from AssessmentMonitoringDetail)
    Dictionary<int, int> questionCountMap;
    if (isPackageMode)
    {
        questionCountMap = await _context.UserPackageAssignments
            .Where(a => siblingIds.Contains(a.AssessmentSessionId))
            .Join(_context.AssessmentPackages.Include(p => p.Questions),
                a => a.AssessmentPackageId,
                p => p.Id,
                (a, p) => new { a.AssessmentSessionId, QuestionCount = p.Questions.Count })
            .ToDictionaryAsync(
                x => x.AssessmentSessionId,
                x => x.QuestionCount);
    }
    else
    {
        questionCountMap = await _context.AssessmentQuestions
            .Where(q => siblingIds.Contains(q.AssessmentSessionId))
            .GroupBy(q => q.AssessmentSessionId)
            .ToDictionaryAsync(g => g.Key, g => g.Count());
    }

    // Step 4: build answered count map (single GROUP BY query, not N+1)
    Dictionary<int, int> answeredCountMap;
    if (isPackageMode)
    {
        answeredCountMap = await _context.PackageUserResponses
            .Where(p => siblingIds.Contains(p.AssessmentSessionId))
            .GroupBy(p => p.AssessmentSessionId)
            .ToDictionaryAsync(g => g.Key, g => g.Count());
    }
    else
    {
        answeredCountMap = await _context.UserResponses
            .Where(r => siblingIds.Contains(r.AssessmentSessionId))
            .GroupBy(r => r.AssessmentSessionId)
            .ToDictionaryAsync(g => g.Key, g => g.Count());
    }

    // Step 5: project to DTOs
    var dtos = sessions.Select(a =>
    {
        string status;
        if (a.CompletedAt != null || a.Score != null)
            status = "Completed";
        else if (a.Status == "Abandoned")
            status = "Abandoned";
        else if (a.StartedAt != null)
            status = "InProgress";
        else
            status = "Not started";

        int? remainingSeconds = null;
        if (status == "InProgress")
            remainingSeconds = Math.Max(0, (a.DurationMinutes * 60) - a.ElapsedSeconds);

        string? result = a.IsPassed == true ? "Pass" : a.IsPassed == false ? "Fail" : null;

        return new
        {
            sessionId      = a.Id,
            status,
            progress       = answeredCountMap.TryGetValue(a.Id, out var ans) ? ans : 0,
            totalQuestions = questionCountMap.TryGetValue(a.Id, out var total) ? total : 0,
            score          = a.Score,
            result,
            remainingSeconds,
            completedAt    = a.CompletedAt
        };
    }).ToList();

    return Json(dtos);
}
```

Key points:
- Status string uses "Not started" (lowercase s) — matches AssessmentMonitoringDetail casing exactly.
- `remainingSeconds` = `Math.Max(0, (DurationMinutes * 60) - ElapsedSeconds)` for InProgress only. ElapsedSeconds is non-nullable int (Phase 42-01 migration, DEFAULT 0).
- `PackageUserResponses` and `UserResponses` are the DbSet names — verify exact names in ApplicationDbContext if build fails.
- No `[ValidateAntiForgeryToken]` — GET endpoint, read-only.
- No `Include(a => a.User)` needed — DTOs don't expose user identity.
  </action>
  <verify>Run `dotnet build` — must produce 0 errors. Then call the endpoint manually (or via curl/browser): `GET /CMP/GetMonitoringProgress?title=TEST&category=OJT&scheduleDate=2026-02-25` — should return a JSON array (empty if no sessions match, non-empty if sessions exist for those params).</verify>
  <done>Build succeeds with 0 errors. Endpoint exists at /CMP/GetMonitoringProgress. Returns JSON array with correct DTO shape including sessionId, status, progress, totalQuestions, score, result, remainingSeconds, completedAt.</done>
</task>

</tasks>

<verification>
1. `dotnet build` — 0 errors, 0 relevant warnings
2. Navigate to `/CMP/GetMonitoringProgress?title=X&category=Y&scheduleDate=Z` as HC/Admin — returns JSON array
3. Navigate as a Worker role — should return 403 Forbidden
4. For an InProgress session: `remainingSeconds` is a non-null integer
5. For a Not started/Completed/Abandoned session: `remainingSeconds` is null
</verification>

<success_criteria>
- GetMonitoringProgress action added to CMPController with correct [HttpGet][Authorize(Roles = "Admin, HC")] attributes
- Returns JSON array with all 8 DTO fields per session
- answered count uses GROUP BY (single query) not N+1
- Status string uses "Not started" (lowercase s) matching existing codebase convention
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/44-real-time-monitoring/44-01-SUMMARY.md`
</output>
