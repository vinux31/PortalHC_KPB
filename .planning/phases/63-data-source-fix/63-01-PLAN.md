---
phase: 63-data-source-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/CDPController.cs
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-03
  - DATA-04

must_haves:
  truths:
    - "ProtonProgress GET action returns data from ProtonDeliverableProgress (not IdpItems)"
    - "GetCoacheeDeliverables JSON endpoint returns deliverable rows for a specific coachee with access control"
    - "Coach role queries CoachCoacheeMapping for real coachee list (not mock data)"
    - "Summary stats (progress %, pending actions, pending approvals) computed from ProtonDeliverableProgress Status values"
    - "Old Progress() action is disabled (returns RedirectToAction Index)"
    - "No-cache response header applied to ProtonProgress action"
  artifacts:
    - path: "Controllers/CDPController.cs"
      provides: "ProtonProgress GET action, GetCoacheeDeliverables JSON endpoint, disabled Progress action"
      contains: "ProtonProgress"
  key_links:
    - from: "CDPController.ProtonProgress"
      to: "ProtonDeliverableProgresses DbSet"
      via: "EF Include chain (ProtonDeliverable -> ProtonSubKompetensi -> ProtonKompetensi)"
      pattern: "_context\\.ProtonDeliverableProgresses.*Include"
    - from: "CDPController.ProtonProgress"
      to: "CoachCoacheeMappings DbSet"
      via: "Coach coachee list query"
      pattern: "_context\\.CoachCoacheeMappings.*CoachId"
    - from: "CDPController.GetCoacheeDeliverables"
      to: "ProtonDeliverableProgresses DbSet"
      via: "JSON endpoint for AJAX coachee switch"
      pattern: "GetCoacheeDeliverables.*coacheeId"
---

<objective>
Create the CDPController backend for the new Proton Progress page: ProtonProgress GET action with role-based data loading, GetCoacheeDeliverables JSON endpoint for AJAX coachee switching, summary stats computation, and disable the old Progress action.

Purpose: Replace the legacy IdpItems-based Progress action with ProtonDeliverableProgress queries and replace mock coachee data with real CoachCoacheeMapping queries. This is the data foundation that the view (Plan 02) will render.

Output: CDPController.cs updated with ProtonProgress(), GetCoacheeDeliverables(), and disabled Progress()
</objective>

<execution_context>
@C:/Users/Administrator/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Administrator/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/63-data-source-fix/63-CONTEXT.md
@.planning/phases/63-data-source-fix/63-RESEARCH.md

@Controllers/CDPController.cs
@Models/TrackingModels.cs
@Models/ProtonModels.cs
@Models/CoachCoacheeMapping.cs
@Data/ApplicationDbContext.cs

<interfaces>
<!-- Key models the executor needs. Extracted from codebase. -->

From Models/TrackingModels.cs:
```csharp
public class TrackingItem
{
    public int Id { get; set; }
    public string Kompetensi { get; set; } = "";
    public string Periode { get; set; } = "";
    public string SubKompetensi { get; set; } = "";
    public string Deliverable { get; set; } = "";
    public string EvidenceStatus { get; set; } = "";
    public string FullEvidencePath { get; set; } = "";
    public string ApprovalSrSpv { get; set; } = "Not Started";
    public string ApprovalSectionHead { get; set; } = "Not Started";
    public string ApprovalHC { get; set; } = "Not Started";
    public string SupervisorComments { get; set; } = "";
}
```

From Models/ProtonModels.cs (lines 81-114):
```csharp
public class ProtonDeliverableProgress
{
    public int Id { get; set; }
    public string CoacheeId { get; set; } = "";
    public int ProtonDeliverableId { get; set; }
    public ProtonDeliverable? ProtonDeliverable { get; set; }
    public string Status { get; set; } = "Locked"; // "Locked", "Active", "Submitted", "Approved", "Rejected"
    public string? EvidencePath { get; set; }
    public string? EvidenceFileName { get; set; }
    public DateTime? SubmittedAt { get; set; }
    public DateTime? ApprovedAt { get; set; }
    public DateTime? RejectedAt { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public string? RejectionReason { get; set; }
    public string? ApprovedById { get; set; }
    public string HCApprovalStatus { get; set; } = "Pending"; // "Pending" or "Reviewed"
    public DateTime? HCReviewedAt { get; set; }
    public string? HCReviewedById { get; set; }
}
```

From Models/CoachCoacheeMapping.cs:
```csharp
public class CoachCoacheeMapping
{
    public int Id { get; set; }
    public string CoachId { get; set; } = "";
    public string CoacheeId { get; set; } = "";
    public bool IsActive { get; set; } = true;
    public DateTime StartDate { get; set; }
    public DateTime? EndDate { get; set; }
}
```

From Data/ApplicationDbContext.cs (DbSet names):
```csharp
public DbSet<CoachCoacheeMapping> CoachCoacheeMappings { get; set; }
public DbSet<ProtonTrackAssignment> ProtonTrackAssignments { get; set; }
public DbSet<ProtonDeliverableProgress> ProtonDeliverableProgresses { get; set; }
public DbSet<ProtonDeliverable> ProtonDeliverableList { get; set; }
```

Role level pattern (used in every CDPController action):
```csharp
var user = await _userManager.GetUserAsync(User);
if (user == null) return Challenge();
var roles = await _userManager.GetRolesAsync(user);
var userRole = roles.FirstOrDefault() ?? "";
int userLevel = user.RoleLevel;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProtonProgress GET action with role-based coachee loading and summary stats</name>
  <files>Controllers/CDPController.cs</files>
  <action>
Add a new `ProtonProgress` action to CDPController (before the existing `Progress` action, around line 1410). This replaces the data layer of the old Progress page.

**Action signature:**
```csharp
[ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
public async Task<IActionResult> ProtonProgress(string? coacheeId = null)
```

**Implementation steps:**

1. **Get current user and role** using the standard pattern:
```csharp
var user = await _userManager.GetUserAsync(User);
if (user == null) return Challenge();
var roles = await _userManager.GetRolesAsync(user);
var userRole = roles.FirstOrDefault() ?? "";
int userLevel = user.RoleLevel;
```

2. **Build coachee list based on role:**

- **Coachee (Level 6):** No dropdown. Set `targetCoacheeId = user.Id`. No coachee list needed. Set `ViewBag.Coachees = null`.

- **Coach (Level 5):** Query CoachCoacheeMapping for real coachees:
```csharp
var coacheeIds = await _context.CoachCoacheeMappings
    .Where(m => m.CoachId == user.Id && m.IsActive)
    .Select(m => m.CoacheeId)
    .ToListAsync();

var coachees = await _context.Users
    .Where(u => coacheeIds.Contains(u.Id))
    .ToListAsync();

// Order by track first, then alphabetically
var assignments = await _context.ProtonTrackAssignments
    .Include(a => a.ProtonTrack)
    .Where(a => coacheeIds.Contains(a.CoacheeId) && a.IsActive)
    .ToDictionaryAsync(a => a.CoacheeId, a => a);

var orderedCoachees = coachees
    .OrderBy(u => assignments.TryGetValue(u.Id, out var a) ? a.ProtonTrack?.Urutan ?? 999 : 999)
    .ThenBy(u => u.FullName)
    .ToList();

ViewBag.Coachees = orderedCoachees;
```
If `coacheeIds` is empty, ViewBag.Coachees is empty list (view shows "Tidak ada coachee" disabled dropdown).
If `coacheeId` param is null, no data loads (dropdown starts empty per CONTEXT.md decision).
If `coacheeId` is provided, verify it's in `coacheeIds` — if not, silently ignore (set `targetCoacheeId = null`).

- **SrSpv/SectionHead (Level 4):** Query all users in same Section. Build coachee list from users where `u.Section == user.Section && u.RoleLevel == 6`. Set `ViewBag.Coachees`. If `coacheeId` provided, verify coachee's Section matches user's Section — if not, silently ignore.

- **HC (Level 2) / Admin (Level 1):** Query all users with RoleLevel == 6. Set `ViewBag.Coachees`. All coacheeIds are valid.

3. **Determine targetCoacheeId:**
- For Coachee: always `user.Id`
- For other roles: the `coacheeId` parameter (after validation). If null or invalid, set to `null` (no data loads).

4. **Load deliverable progress data (only if targetCoacheeId is not null):**
```csharp
List<TrackingItem> data = new();
int progressPercent = 0;
int pendingActions = 0;
int pendingApprovals = 0;
string trackLabel = "";

if (!string.IsNullOrEmpty(targetCoacheeId))
{
    var progresses = await _context.ProtonDeliverableProgresses
        .Include(p => p.ProtonDeliverable)
            .ThenInclude(d => d.ProtonSubKompetensi)
                .ThenInclude(s => s.ProtonKompetensi)
        .Where(p => p.CoacheeId == targetCoacheeId)
        .OrderBy(p => p.ProtonDeliverable.ProtonSubKompetensi.ProtonKompetensi.Urutan)
            .ThenBy(p => p.ProtonDeliverable.ProtonSubKompetensi.Urutan)
            .ThenBy(p => p.ProtonDeliverable.Urutan)
        .ToListAsync();

    // Map ProtonDeliverableProgress to TrackingItem
    data = progresses.Select(p => new TrackingItem
    {
        Id = p.Id,
        Kompetensi = p.ProtonDeliverable?.ProtonSubKompetensi?.ProtonKompetensi?.NamaKompetensi ?? "",
        SubKompetensi = p.ProtonDeliverable?.ProtonSubKompetensi?.NamaSubKompetensi ?? "",
        Deliverable = p.ProtonDeliverable?.NamaDeliverable ?? "",
        EvidenceStatus = p.EvidencePath != null ? "Uploaded" : "Pending",
        FullEvidencePath = p.EvidencePath ?? "",
        ApprovalSrSpv = p.Status == "Approved" ? "Approved"
                      : p.Status == "Rejected" ? "Rejected"
                      : p.Status == "Submitted" ? "Pending"
                      : "Not Started",
        ApprovalSectionHead = p.Status == "Approved" ? "Approved"
                            : p.Status == "Rejected" ? "Rejected"
                            : p.Status == "Submitted" ? "Pending"
                            : "Not Started",
        ApprovalHC = p.HCApprovalStatus == "Reviewed" ? "Approved" : "Pending",
        SupervisorComments = p.RejectionReason ?? "",
    }).ToList();

    // Compute summary stats (DATA-03)
    int total = progresses.Count;
    double weightedSum = progresses.Sum(p =>
        p.Status == "Approved" ? 1.0 :
        p.Status == "Submitted" ? 0.5 : 0.0);
    progressPercent = total > 0 ? (int)(weightedSum / total * 100) : 0;
    pendingActions = progresses.Count(p => p.Status == "Active" || p.Status == "Rejected");
    pendingApprovals = progresses.Count(p => p.Status == "Submitted");

    // Get track label for display outside table
    var assignment = await _context.ProtonTrackAssignments
        .Include(a => a.ProtonTrack)
        .FirstOrDefaultAsync(a => a.CoacheeId == targetCoacheeId && a.IsActive);
    if (assignment?.ProtonTrack != null)
    {
        trackLabel = $"{assignment.ProtonTrack.TrackType} Tahun {assignment.ProtonTrack.TahunKe}";
    }
}
```

5. **Set ViewBag values:**
```csharp
ViewBag.UserRole = userRole;
ViewBag.UserLevel = userLevel;
ViewBag.UserSection = user.Section;
ViewBag.UserUnit = user.Unit;
ViewBag.UserFullName = user.FullName;
ViewBag.SelectedCoacheeId = targetCoacheeId;
ViewBag.ProgressPercent = progressPercent;
ViewBag.PendingActions = pendingActions;
ViewBag.PendingApprovals = pendingApprovals;
ViewBag.TrackLabel = trackLabel;

// For coachee, resolve display name
if (!string.IsNullOrEmpty(targetCoacheeId))
{
    var coacheeUser = await _context.Users.FindAsync(targetCoacheeId);
    ViewBag.CoacheeName = coacheeUser?.FullName ?? "";
}
```

6. **Handle error cases per CONTEXT.md:**
- If Coachee has no track assignment: pass empty data list but set `ViewBag.NoTrackMessage = "Coachee ini belum memiliki penugasan track"` (view checks `data.Count == 0 && trackLabel == ""`)
- If coachee has track but no progress records: set `ViewBag.NoProgressMessage = "Data progress tidak ditemukan"`

7. **Return view:**
```csharp
return View(data);
```

**Also disable the old Progress action** by replacing its entire body (lines 1412-1488) with:
```csharp
public IActionResult Progress() => RedirectToAction("Index");
```

**IMPORTANT anti-patterns to avoid:**
- Do NOT query IdpItems anywhere in ProtonProgress — that's the entire point of this phase
- Do NOT use Unit-based scoping for Coach role — use CoachCoacheeMapping only
- Do NOT use lazy loading — always use .Include().ThenInclude() explicitly
- Do NOT redirect /CDP/Progress to /CDP/ProtonProgress — CONTEXT.md says disable (redirect to Index)
  </action>
  <verify>
    <automated>cd "C:/Users/Administrator/Desktop/PortalHC_KPB/.claude/worktrees/terminal-a" && dotnet build --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>
- ProtonProgress GET action exists in CDPController with [ResponseCache(Duration=0, NoStore=true)]
- Role-based coachee list: Coach uses CoachCoacheeMapping, SrSpv uses Section filter, HC/Admin sees all
- TrackingItem mapping uses ProtonDeliverableProgress (not IdpItems)
- Summary stats computed: progressPercent, pendingActions, pendingApprovals
- Track label loaded from ProtonTrackAssignment for display outside table
- Old Progress() action replaced with redirect to Index
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GetCoacheeDeliverables JSON endpoint for AJAX coachee switching</name>
  <files>Controllers/CDPController.cs</files>
  <action>
Add a new `GetCoacheeDeliverables` JSON endpoint to CDPController (after the ProtonProgress action). This endpoint powers the AJAX coachee dropdown switching (no full page reload per CONTEXT.md).

**Action signature:**
```csharp
[HttpGet]
[ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
public async Task<IActionResult> GetCoacheeDeliverables(string coacheeId)
```

**Implementation steps:**

1. **Get current user and role** using the standard pattern.

2. **Access control validation** (prevents URL manipulation per CONTEXT.md — Pitfall 4 from RESEARCH.md):
```csharp
// Verify caller has access to this coacheeId
if (userLevel == 6) // Coachee
{
    if (coacheeId != user.Id) coacheeId = user.Id; // silently redirect to own data
}
else if (userLevel == 5) // Coach
{
    var hasAccess = await _context.CoachCoacheeMappings
        .AnyAsync(m => m.CoachId == user.Id && m.CoacheeId == coacheeId && m.IsActive);
    if (!hasAccess) return Json(new { error = "unauthorized", data = (object?)null });
}
else if (userLevel == 4) // SrSpv/SectionHead
{
    var coacheeUser = await _context.Users.FindAsync(coacheeId);
    if (coacheeUser == null || coacheeUser.Section != user.Section)
        return Json(new { error = "unauthorized", data = (object?)null });
}
// Level 1-2 (HC/Admin): allow all
```

3. **Load deliverable progress** (same query as Task 1):
```csharp
var progresses = await _context.ProtonDeliverableProgresses
    .Include(p => p.ProtonDeliverable)
        .ThenInclude(d => d.ProtonSubKompetensi)
            .ThenInclude(s => s.ProtonKompetensi)
    .Where(p => p.CoacheeId == coacheeId)
    .OrderBy(p => p.ProtonDeliverable.ProtonSubKompetensi.ProtonKompetensi.Urutan)
        .ThenBy(p => p.ProtonDeliverable.ProtonSubKompetensi.Urutan)
        .ThenBy(p => p.ProtonDeliverable.Urutan)
    .ToListAsync();
```

4. **Map to anonymous JSON objects:**
```csharp
var items = progresses.Select(p => new
{
    id = p.Id,
    kompetensi = p.ProtonDeliverable?.ProtonSubKompetensi?.ProtonKompetensi?.NamaKompetensi ?? "",
    subKompetensi = p.ProtonDeliverable?.ProtonSubKompetensi?.NamaSubKompetensi ?? "",
    deliverable = p.ProtonDeliverable?.NamaDeliverable ?? "",
    evidenceStatus = p.EvidencePath != null ? "Uploaded" : "Pending",
    approvalSrSpv = p.Status == "Approved" ? "Approved" : p.Status == "Rejected" ? "Rejected" : p.Status == "Submitted" ? "Pending" : "Not Started",
    approvalSectionHead = p.Status == "Approved" ? "Approved" : p.Status == "Rejected" ? "Rejected" : p.Status == "Submitted" ? "Pending" : "Not Started",
    approvalHC = p.HCApprovalStatus == "Reviewed" ? "Approved" : "Pending",
    supervisorComments = p.RejectionReason ?? "",
    deliverableId = p.ProtonDeliverableId,
}).ToList();
```

5. **Compute summary stats:**
```csharp
int total = progresses.Count;
double weightedSum = progresses.Sum(p =>
    p.Status == "Approved" ? 1.0 :
    p.Status == "Submitted" ? 0.5 : 0.0);
int progressPercent = total > 0 ? (int)(weightedSum / total * 100) : 0;
int pendingActions = progresses.Count(p => p.Status == "Active" || p.Status == "Rejected");
int pendingApprovals = progresses.Count(p => p.Status == "Submitted");
```

6. **Get track label and coachee name:**
```csharp
var assignment = await _context.ProtonTrackAssignments
    .Include(a => a.ProtonTrack)
    .FirstOrDefaultAsync(a => a.CoacheeId == coacheeId && a.IsActive);
string trackLabel = assignment?.ProtonTrack != null
    ? $"{assignment.ProtonTrack.TrackType} Tahun {assignment.ProtonTrack.TahunKe}"
    : "";

var coacheeUser = await _context.Users.FindAsync(coacheeId);
string coacheeName = coacheeUser?.FullName ?? "";
```

7. **Return JSON response:**
```csharp
return Json(new
{
    items,
    stats = new { progressPercent, pendingActions, pendingApprovals },
    trackLabel,
    coacheeName,
    noTrack = string.IsNullOrEmpty(trackLabel) && total == 0,
    noProgress = !string.IsNullOrEmpty(trackLabel) && total == 0,
});
```

**IMPORTANT:** Use camelCase property names in the anonymous object (JavaScript convention for JSON). The fetch() client in Plan 02 will consume this directly.
  </action>
  <verify>
    <automated>cd "C:/Users/Administrator/Desktop/PortalHC_KPB/.claude/worktrees/terminal-a" && dotnet build --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>
- GetCoacheeDeliverables JSON endpoint exists and compiles
- Access control validates: Coach checks CoachCoacheeMapping, SrSpv checks Section, Coachee can only see own data
- Returns JSON with items array, stats object (progressPercent, pendingActions, pendingApprovals), trackLabel, coacheeName
- No-cache header applied
- Unauthorized access returns error JSON (not 403)
  </done>
</task>

</tasks>

<verification>
1. `dotnet build --no-restore` passes without errors
2. CDPController has ProtonProgress action with [ResponseCache(Duration=0, NoStore=true)]
3. CDPController has GetCoacheeDeliverables action with access control
4. Old Progress() action returns RedirectToAction("Index")
5. No IdpItems reference in ProtonProgress or GetCoacheeDeliverables
6. CoachCoacheeMapping queried (not mock data) for Coach role
7. Summary stats use correct formula: Approved=1.0, Submitted=0.5, others=0.0
</verification>

<success_criteria>
- Build succeeds with zero compilation errors
- ProtonProgress action queries ProtonDeliverableProgresses (DATA-01)
- Coach coachee list comes from CoachCoacheeMapping (DATA-02)
- Stats computed from Status values with correct weights (DATA-03)
- No-cache headers applied, AJAX endpoint ready for Plan 02 view (DATA-04)
- Old Progress action disabled
</success_criteria>

<output>
After completion, create `.planning/phases/63-data-source-fix/63-01-SUMMARY.md`
</output>
