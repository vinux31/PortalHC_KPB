---
phase: 64-functional-filters
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Models/TrackingModels.cs
  - Controllers/CDPController.cs
autonomous: true
requirements: [FILT-01, FILT-02, FILT-03, UI-03]

must_haves:
  truths:
    - "ProtonProgress action accepts bagian, unit, trackType, tahun, coacheeId GET params and applies them as EF Where clauses before materialization"
    - "HC/Admin selecting Bagian=GAST receives only deliverable rows for coachees whose Section matches GAST"
    - "Coach selecting a coachee sees only that coachee's deliverable rows — role scope enforced server-side via CoachCoacheeMapping"
    - "Selecting Track=Panelman and/or Tahun=1 returns only matching assignments via EF Where on ProtonTrack navigation chain"
    - "Role-scoped data enforced: Level 5 scoped via CoachCoacheeMapping, Level 4 scoped via user.Section, Level 1-2 unrestricted — URL params cannot expand scope"
    - "TrackingItem has CoacheeId and CoacheeName fields so multi-coachee results identify which row belongs to whom"
    - "ViewBag populated with filter option lists (AllBagian, AllUnits, AllTracks, AllTahun, coachee list) and selected values for view rendering"
  artifacts:
    - path: "Models/TrackingModels.cs"
      provides: "TrackingItem with CoacheeId and CoacheeName fields"
      contains: "CoacheeId"
    - path: "Controllers/CDPController.cs"
      provides: "ProtonProgress GET action with filter params + role-scoped query"
      contains: "bagian.*unit.*trackType.*tahun"
  key_links:
    - from: "Controllers/CDPController.cs"
      to: "Models/OrganizationStructure.cs"
      via: "OrganizationStructure.GetAllSections() and GetUnitsForSection() for Bagian/Unit filter data"
      pattern: "OrganizationStructure\\.Get"
    - from: "Controllers/CDPController.cs"
      to: "ProtonDeliverableProgress → ProtonTrack"
      via: "EF Where clause filtering by TrackType and TahunKe"
      pattern: "ProtonTrack.*TrackType"
---

<objective>
Extend CDPController.ProtonProgress to accept all filter parameters (bagian, unit, trackType, tahun, coacheeId) and wire them to EF Core Where clauses with server-enforced role scoping. Extend TrackingItem model with CoacheeId/CoacheeName for multi-coachee result sets.

Purpose: Transform ProtonProgress from a single-coachee AJAX-driven page into a multi-parameter filtered page where queries run at the database level — not in-memory post-filter. Server-side role enforcement remains the authority; URL params only narrow within role scope.

Output: Updated CDPController.cs with refactored ProtonProgress action, updated TrackingModels.cs with CoacheeId/CoacheeName fields, ViewBag populated for all filter dropdowns.
</objective>

<execution_context>
@C:/Users/Administrator/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Administrator/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-functional-filters/64-CONTEXT.md
@.planning/phases/64-functional-filters/64-RESEARCH.md
@.planning/phases/63-data-source-fix/63-01-SUMMARY.md
@.planning/phases/63-data-source-fix/63-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From Models/TrackingModels.cs (CURRENT — to be extended):
```csharp
namespace HcPortal.Models
{
    public class TrackingItem
    {
        public int Id { get; set; }
        public string Kompetensi { get; set; } = "";
        public string Periode { get; set; } = "";
        public string SubKompetensi { get; set; } = "";
        public string Deliverable { get; set; } = "";
        public string EvidenceStatus { get; set; } = "";
        public string FullEvidencePath { get; set; } = "";
        public string ApprovalSrSpv { get; set; } = "Not Started";
        public string ApprovalSectionHead { get; set; } = "Not Started";
        public string ApprovalHC { get; set; } = "Not Started";
        public string SupervisorComments { get; set; } = "";
    }
}
```

From Models/OrganizationStructure.cs:
```csharp
public static class OrganizationStructure
{
    public static readonly Dictionary<string, List<string>> SectionUnits;
    public static List<string> GetAllSections();
    public static List<string> GetUnitsForSection(string section);
    public static string? GetSectionForUnit(string unit);
}
```

From Models/ProtonModels.cs (relevant):
```csharp
public class ProtonTrack {
    public int Id { get; set; }
    public string TrackType { get; set; } = "";  // "Panelman" or "Operator"
    public string TahunKe { get; set; } = "";    // "Tahun 1", "Tahun 2", "Tahun 3"
    public int Urutan { get; set; }
}
public class ProtonDeliverableProgress {
    public int Id { get; set; }
    public string CoacheeId { get; set; } = "";
    public int ProtonDeliverableId { get; set; }
    public ProtonDeliverable? ProtonDeliverable { get; set; }
    public string Status { get; set; } = "Locked";
    public string? EvidencePath { get; set; }
    public string HCApprovalStatus { get; set; } = "Pending";
    public string? RejectionReason { get; set; }
}
```

ProtonProgress action signature (CURRENT — at line 1413 of CDPController.cs):
```csharp
public async Task<IActionResult> ProtonProgress(string? coacheeId = null)
```

GetCoacheeDeliverables action (at line 1579 — KEEP for now but no longer primary):
```csharp
public async Task<IActionResult> GetCoacheeDeliverables(string coacheeId)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TrackingItem model and refactor ProtonProgress action with filter params</name>
  <files>Models/TrackingModels.cs, Controllers/CDPController.cs</files>
  <action>
**Step 1: Extend TrackingItem** in `Models/TrackingModels.cs`:
Add two new string properties after the existing fields:
```csharp
public string CoacheeId { get; set; } = "";
public string CoacheeName { get; set; } = "";
```

**Step 2: Refactor ProtonProgress action signature** in `Controllers/CDPController.cs` (line 1413):
Change from `ProtonProgress(string? coacheeId = null)` to:
```csharp
public async Task<IActionResult> ProtonProgress(
    string? coacheeId = null,
    string? bagian = null,
    string? unit = null,
    string? trackType = null,
    string? tahun = null)
```

**Step 3: Rewrite the role-scoped coachee ID derivation + filter application** (replace lines ~1421-1484):

The new logic must follow this sequence:
1. Derive `scopedCoacheeIds` based on user role level (NEVER expandable by URL params)
2. Apply bagian/unit filters to narrow scopedCoacheeIds (HC/Admin only for bagian; Level 4 for unit within their section)
3. Apply coacheeId param to select one coachee (validate against scopedCoacheeIds)
4. Build deliverable query with trackType/tahun Where clauses
5. Populate ViewBag for all filter dropdowns

**Detailed implementation:**

```csharp
// --- STEP 1: Role-scoped coachee IDs (SERVER ENFORCEMENT) ---
List<string> scopedCoacheeIds;
List<ApplicationUser>? coacheeList = null;

if (userLevel <= 2) // HC/Admin — see all coachees
{
    scopedCoacheeIds = await _context.Users
        .Where(u => u.RoleLevel == 6)
        .Select(u => u.Id).ToListAsync();
}
else if (userLevel == 4) // SrSpv/SectionHead — same section only
{
    scopedCoacheeIds = await _context.Users
        .Where(u => u.Section == user.Section && u.RoleLevel == 6)
        .Select(u => u.Id).ToListAsync();
}
else if (userLevel == 5) // Coach — CoachCoacheeMapping only
{
    scopedCoacheeIds = await _context.CoachCoacheeMappings
        .Where(m => m.CoachId == user.Id && m.IsActive)
        .Select(m => m.CoacheeId).ToListAsync();
}
else // Level 6 (Coachee)
{
    scopedCoacheeIds = new List<string> { user.Id };
}

// --- STEP 2: Apply Bagian filter (HC/Admin only) ---
if (userLevel <= 2 && !string.IsNullOrEmpty(bagian))
{
    var validSections = OrganizationStructure.GetAllSections();
    if (validSections.Contains(bagian))
    {
        scopedCoacheeIds = await _context.Users
            .Where(u => scopedCoacheeIds.Contains(u.Id) && u.Section == bagian)
            .Select(u => u.Id).ToListAsync();
    }
    else
    {
        bagian = null; // silently ignore invalid bagian
    }
}

// --- STEP 3: Apply Unit filter ---
if (!string.IsNullOrEmpty(unit))
{
    if (userLevel <= 2)
    {
        // HC/Admin: any unit (but must be within selected bagian if set)
        scopedCoacheeIds = await _context.Users
            .Where(u => scopedCoacheeIds.Contains(u.Id) && u.Unit == unit)
            .Select(u => u.Id).ToListAsync();
    }
    else if (userLevel == 4)
    {
        // SrSpv/SectionHead: validate unit is in their section
        var allowedUnits = OrganizationStructure.GetUnitsForSection(user.Section ?? "");
        if (allowedUnits.Contains(unit))
        {
            scopedCoacheeIds = await _context.Users
                .Where(u => scopedCoacheeIds.Contains(u.Id) && u.Unit == unit)
                .Select(u => u.Id).ToListAsync();
        }
        else
        {
            unit = null; // silently ignore unauthorized unit
        }
    }
    // Level 5/6: unit param ignored (implicit scope)
}

// --- STEP 4: Apply Track filter to Coach's coachee list (FILT-03 cascade for Coach role) ---
if (userLevel == 5 && !string.IsNullOrEmpty(trackType))
{
    var trackFilteredIds = await _context.ProtonTrackAssignments
        .Where(a => scopedCoacheeIds.Contains(a.CoacheeId) && a.IsActive
                     && a.ProtonTrack!.TrackType == trackType)
        .Select(a => a.CoacheeId).Distinct().ToListAsync();
    // Keep only coachees that have the selected track
    scopedCoacheeIds = scopedCoacheeIds.Where(id => trackFilteredIds.Contains(id)).ToList();
}

// --- STEP 5: Build coachee dropdown list (after scope narrowing) ---
coacheeList = await _context.Users
    .Where(u => scopedCoacheeIds.Contains(u.Id))
    .OrderBy(u => u.FullName)
    .ToListAsync();

// --- STEP 6: Apply single coachee filter ---
string? targetCoacheeId = null;
if (!string.IsNullOrEmpty(coacheeId) && scopedCoacheeIds.Contains(coacheeId))
{
    targetCoacheeId = coacheeId;
}
// For Level 6 (Coachee): always own data
if (userLevel == 6)
{
    targetCoacheeId = user.Id;
}

// Determine which coachee IDs to load data for
var dataCoacheeIds = !string.IsNullOrEmpty(targetCoacheeId)
    ? new List<string> { targetCoacheeId }
    : scopedCoacheeIds;
```

**Step 4: Build deliverable query with Track/Tahun Where clauses** (replace lines ~1493-1553):

```csharp
// Build base query
var query = _context.ProtonDeliverableProgresses
    .Include(p => p.ProtonDeliverable)
        .ThenInclude(d => d!.ProtonSubKompetensi)
            .ThenInclude(s => s!.ProtonKompetensi)
                .ThenInclude(k => k!.ProtonTrack)
    .Where(p => dataCoacheeIds.Contains(p.CoacheeId));

// Apply Track filter (FILT-03)
if (!string.IsNullOrEmpty(trackType))
    query = query.Where(p =>
        p.ProtonDeliverable!.ProtonSubKompetensi!.ProtonKompetensi!.ProtonTrack!.TrackType == trackType);

// Apply Tahun filter (FILT-03)
if (!string.IsNullOrEmpty(tahun))
    query = query.Where(p =>
        p.ProtonDeliverable!.ProtonSubKompetensi!.ProtonKompetensi!.ProtonTrack!.TahunKe == tahun);

var progresses = await query
    .OrderBy(p => p.ProtonDeliverable!.ProtonSubKompetensi!.ProtonKompetensi!.Urutan)
    .ThenBy(p => p.ProtonDeliverable!.ProtonSubKompetensi!.Urutan)
    .ThenBy(p => p.ProtonDeliverable!.Urutan)
    .ToListAsync();
```

**CRITICAL**: The `.ThenInclude(k => k!.ProtonTrack)` is NEW — Phase 63 did NOT include ProtonTrack in the chain. It must be added for Track/Tahun filtering to work (see Pitfall 4 in RESEARCH.md).

**Step 5: Map progresses to TrackingItem with CoacheeId/CoacheeName** (replace lines ~1506-1524):

Build a user dictionary for coachee names:
```csharp
var coacheeNameDict = coacheeList?.ToDictionary(u => u.Id, u => u.FullName)
    ?? new Dictionary<string, string>();

data = progresses.Select(p => new TrackingItem
{
    Id = p.Id,
    Kompetensi = p.ProtonDeliverable?.ProtonSubKompetensi?.ProtonKompetensi?.NamaKompetensi ?? "",
    SubKompetensi = p.ProtonDeliverable?.ProtonSubKompetensi?.NamaSubKompetensi ?? "",
    Deliverable = p.ProtonDeliverable?.NamaDeliverable ?? "",
    EvidenceStatus = p.EvidencePath != null ? "Uploaded" : "Pending",
    FullEvidencePath = p.EvidencePath ?? "",
    ApprovalSrSpv = p.Status == "Approved" ? "Approved"
                  : p.Status == "Rejected" ? "Rejected"
                  : p.Status == "Submitted" ? "Pending"
                  : "Not Started",
    ApprovalSectionHead = p.Status == "Approved" ? "Approved"
                        : p.Status == "Rejected" ? "Rejected"
                        : p.Status == "Submitted" ? "Pending"
                        : "Not Started",
    ApprovalHC = p.HCApprovalStatus == "Reviewed" ? "Approved" : "Pending",
    SupervisorComments = p.RejectionReason ?? "",
    CoacheeId = p.CoacheeId,
    CoacheeName = coacheeNameDict.TryGetValue(p.CoacheeId, out var name) ? name : "",
}).ToList();
```

**Step 6: Compute stats** — keep same formula but over ALL progresses (multi-coachee aggregate):
```csharp
int total = progresses.Count;
double weightedSum = progresses.Sum(p =>
    p.Status == "Approved" ? 1.0 :
    p.Status == "Submitted" ? 0.5 : 0.0);
progressPercent = total > 0 ? (int)(weightedSum / total * 100) : 0;
pendingActions = progresses.Count(p => p.Status == "Active" || p.Status == "Rejected");
pendingApprovals = progresses.Count(p => p.Status == "Submitted");
```

Remove the single-coachee `if (!string.IsNullOrEmpty(targetCoacheeId))` guard around the query block — data now loads for all scoped coachees by default (unless filtered to one).

Remove or simplify the trackLabel lookup — with multi-coachee, trackLabel only applies when one coachee is selected.

**Step 7: Populate ViewBag for filter dropdowns and selected state:**
```csharp
// Filter option lists
ViewBag.AllBagian = OrganizationStructure.GetAllSections();
ViewBag.AllUnits = !string.IsNullOrEmpty(bagian)
    ? OrganizationStructure.GetUnitsForSection(bagian)
    : new List<string>();
ViewBag.AllTracks = new List<string> { "Panelman", "Operator" };
ViewBag.AllTahun = new List<string> { "Tahun 1", "Tahun 2", "Tahun 3" };
ViewBag.Coachees = (userLevel == 6) ? null : coacheeList;

// Selected filter values (for view to render selected attributes)
ViewBag.SelectedBagian = bagian;
ViewBag.SelectedUnit = unit;
ViewBag.SelectedTrackType = trackType;
ViewBag.SelectedTahun = tahun;
ViewBag.SelectedCoacheeId = targetCoacheeId;

// Counts for "Menampilkan X dari Y data"
var totalBeforeFilter = scopedCoacheeIds.Count > 0
    ? await _context.ProtonDeliverableProgresses
        .CountAsync(p => scopedCoacheeIds.Contains(p.CoacheeId))
    : 0;
ViewBag.TotalCount = totalBeforeFilter;
ViewBag.FilteredCount = data.Count;

// Existing ViewBag values
ViewBag.UserRole = userRole;
ViewBag.UserLevel = userLevel;
ViewBag.UserSection = user.Section;
ViewBag.UserUnit = user.Unit;
ViewBag.UserFullName = user.FullName;
ViewBag.ProgressPercent = progressPercent;
ViewBag.PendingActions = pendingActions;
ViewBag.PendingApprovals = pendingApprovals;

// Track label: only meaningful for single coachee
if (!string.IsNullOrEmpty(targetCoacheeId))
{
    var assignment = await _context.ProtonTrackAssignments
        .Include(a => a.ProtonTrack)
        .FirstOrDefaultAsync(a => a.CoacheeId == targetCoacheeId && a.IsActive);
    ViewBag.TrackLabel = assignment?.ProtonTrack != null
        ? $"{assignment.ProtonTrack.TrackType} {assignment.ProtonTrack.TahunKe}"
        : "";
    var coacheeUser = await _context.Users.FindAsync(targetCoacheeId);
    ViewBag.CoacheeName = coacheeUser?.FullName ?? "";
}
else
{
    ViewBag.TrackLabel = "";
    ViewBag.CoacheeName = "";
}

// Empty result messages
if (data.Count == 0)
{
    ViewBag.EmptyMessage = "Tidak ada data yang sesuai filter";
}

return View(data);
```

**Step 8: Handle empty result and error messages:**
- Remove the old `NoTrackMessage` / `NoProgressMessage` logic (single-coachee specific)
- Add `ViewBag.EmptyMessage` when `data.Count == 0` for the generic empty-filter message per CONTEXT.md

**IMPORTANT NOTES:**
- Do NOT delete `GetCoacheeDeliverables` action — leave it intact. Plan 02 will remove AJAX usage from the view, but the endpoint stays for now.
- Keep the `[ResponseCache(Duration=0, Location=ResponseCacheLocation.None, NoStore=true)]` attribute.
- Validate bagian against `OrganizationStructure.GetAllSections()` to prevent scope bypass.
- Validate unit against `OrganizationStructure.GetUnitsForSection()` for Level 4 users (Pitfall 7).
- Track dropdown values should use the literal strings from ProtonTrack entity (Panelman, Operator), NOT query the DB for distinct values — these are known/fixed values.
  </action>
  <verify>
    <automated>cd "C:/Users/Administrator/Desktop/PortalHC_KPB/.claude/worktrees/terminal-a" && dotnet build --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>
    - TrackingItem has CoacheeId and CoacheeName string properties
    - ProtonProgress action accepts bagian, unit, trackType, tahun, coacheeId params
    - EF Where clauses compose before ToListAsync (no in-memory filtering)
    - Role scoping enforced: Level 5 via CoachCoacheeMapping, Level 4 via user.Section, Level 1-2 unrestricted
    - HC/Admin bagian filter validated against OrganizationStructure.GetAllSections()
    - SrSpv unit filter validated against OrganizationStructure.GetUnitsForSection(user.Section)
    - ProtonTrack ThenInclude added for Track/Tahun filter chain
    - ViewBag populated with AllBagian, AllUnits, AllTracks, AllTahun, Coachees, and all Selected* values
    - ViewBag.TotalCount and ViewBag.FilteredCount populated for result count display
    - Build succeeds with 0 errors
  </done>
</task>

</tasks>

<verification>
1. `dotnet build --no-restore` — 0 errors
2. Grep for `ProtonProgress.*bagian.*unit.*trackType.*tahun` in CDPController.cs — confirms all params in signature
3. Grep for `CoacheeId.*CoacheeName` in TrackingModels.cs — confirms model extension
4. Grep for `OrganizationStructure.GetAllSections\|GetUnitsForSection` in CDPController.cs — confirms Bagian/Unit validation
5. Grep for `ProtonTrack!.TrackType` in CDPController.cs — confirms Track filter Where clause
6. Grep for `ViewBag.AllBagian\|ViewBag.SelectedBagian` in CDPController.cs — confirms ViewBag population
</verification>

<success_criteria>
- ProtonProgress action compiles and accepts 5 filter parameters
- TrackingItem model has CoacheeId and CoacheeName fields
- All filter params wired to EF Where clauses before materialization
- Role scoping is server-enforced and cannot be bypassed by URL manipulation
- ViewBag populated with all dropdown data and selected values for Plan 02 view to consume
</success_criteria>

<output>
After completion, create `.planning/phases/64-functional-filters/64-01-SUMMARY.md`
</output>
