---
phase: 66-ui-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Controllers/CDPController.cs
autonomous: true
requirements:
  - UI-02
  - UI-04

must_haves:
  truths:
    - "ProtonProgress action accepts a `page` query parameter and uses it for group-boundary pagination"
    - "ViewBag.CurrentPage, ViewBag.TotalPages, ViewBag.PageFirstRow, ViewBag.PageLastRow are set on every response"
    - "The model passed to the view contains only the rows for the current page (not all rows)"
    - "Any filter change preserves all other filter params in the pagination links (filter state not lost)"
    - "ViewBag.EmptyScenario is set to one of: 'no_coachees', 'no_filter_match', 'no_deliverables', or empty string when data exists"
    - "Summary stats (progressPercent, pendingActions, pendingApprovals) are computed from the full dataset before pagination slicing"
  artifacts:
    - path: Controllers/CDPController.cs
      provides: "ProtonProgress action with pagination + empty state scenario detection"
      contains: "pageNumber, pagesGroups, ViewBag.CurrentPage, ViewBag.TotalPages, ViewBag.EmptyScenario"
  key_links:
    - from: Controllers/CDPController.cs
      to: Views/CDP/ProtonProgress.cshtml
      via: "ViewBag.CurrentPage, ViewBag.TotalPages, ViewBag.PageFirstRow, ViewBag.PageLastRow, ViewBag.EmptyScenario passed to view"
      pattern: "ViewBag\\.CurrentPage|ViewBag\\.TotalPages|ViewBag\\.EmptyScenario"
---

<objective>
Add server-side pagination logic and empty state scenario detection to the ProtonProgress controller action.

Purpose: Phase 66 UI Polish requires (UI-04) group-boundary-respecting pagination so large datasets don't load all rows at once, and (UI-02) scenario-aware empty state detection so the view can render the correct message + optional "Hapus Filter" button. This plan handles the server-side half; Plan 02 handles the view rendering.

Output:
- CDPController.ProtonProgress action updated to: (a) slice data into group-boundary-respecting pages, (b) expose ViewBag pagination fields, (c) detect and expose empty state scenario via ViewBag.EmptyScenario
</objective>

<execution_context>
@C:/Users/Administrator/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Administrator/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-ui-polish/66-CONTEXT.md
@.planning/phases/66-ui-polish/66-RESEARCH.md
@Controllers/CDPController.cs

<interfaces>
<!-- Key types and contracts extracted from CDPController.cs ProtonProgress action (lines 1395-1659) -->

Current ProtonProgress action signature:
```csharp
public async Task<IActionResult> ProtonProgress(
    string? coacheeId = null,
    string? bagian = null,
    string? unit = null,
    string? trackType = null,
    string? tahun = null)
```

After Phase 65 completion, the action:
1. Computes `scopedCoacheeIds` (role-scoped list of coachee IDs)
2. Applies Bagian/Unit/Track/Tahun filters to `scopedCoacheeIds`
3. Builds `coacheeList` (ApplicationUser list for dropdown)
4. Determines `targetCoacheeId` and `dataCoacheeIds`
5. Builds `query` and materializes `progresses` (List&lt;ProtonDeliverableProgress&gt;) at line 1537
6. Maps `progresses` → `data` (List&lt;TrackingItem&gt;) at line 1560
7. Computes summary stats (progressPercent, pendingActions, pendingApprovals) using `progresses` at lines 1584-1598
8. Sets ViewBag values and returns `View(data)` at line 1658

Current ViewBag fields set in ProtonProgress:
- ViewBag.AllBagian, ViewBag.AllUnits, ViewBag.AllTracks, ViewBag.AllTahun
- ViewBag.Coachees, ViewBag.SelectedBagian, ViewBag.SelectedUnit, ViewBag.SelectedTrackType, ViewBag.SelectedTahun, ViewBag.SelectedCoacheeId
- ViewBag.TotalCount (total before filter), ViewBag.FilteredCount (total after filter = data.Count before pagination)
- ViewBag.UserRole, ViewBag.UserLevel, ViewBag.UserSection, ViewBag.UserUnit, ViewBag.UserFullName
- ViewBag.ProgressPercent, ViewBag.PendingActions, ViewBag.PendingApprovals
- ViewBag.TrackLabel, ViewBag.CoacheeName
- ViewBag.EmptyMessage (line 1655 — currently a simple string)

TrackingItem model fields used by view:
- Kompetensi, SubKompetensi, Deliverable, CoacheeName, CoacheeId, Status
- EvidenceStatus, FullEvidencePath, ApprovalSrSpv, ApprovalSectionHead, ApprovalHC
- SrSpvApproverName, SrSpvApprovedAt, ShApproverName, ShApprovedAt, HcReviewerName, HcReviewedAt, SupervisorComments, Id
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add `page` parameter and group-boundary pagination to ProtonProgress action</name>
  <files>Controllers/CDPController.cs</files>
  <action>
Modify the `ProtonProgress` action in CDPController.cs:

**1. Add `page` parameter to method signature:**
```csharp
public async Task<IActionResult> ProtonProgress(
    string? coacheeId = null,
    string? bagian = null,
    string? unit = null,
    string? trackType = null,
    string? tahun = null,
    int page = 1)
```

**2. After `data = progresses.Select(p => new TrackingItem {...}).ToList();` (line ~1582), INSERT the pagination logic BEFORE summary stats computation:**

The summary stats (progressPercent, pendingActions, pendingApprovals) must be computed from the FULL `progresses` list (lines ~1584-1598). Do NOT move those. The pagination slicing only affects `data` (the final model passed to the view).

Insert this block between the `data = progresses.Select(...)` line and the `// Compute summary stats` comment:

```csharp
// --- PAGINATION: Group-boundary slicing (UI-04) ---
const int targetRowsPerPage = 20;
int pageNumber = Math.Max(1, page);

// Group data by Kompetensi (then SubKompetensi) to build pages that never split a group
// For multi-coachee view: group by CoacheeName > Kompetensi > SubKompetensi
// For single-coachee view: group by Kompetensi > SubKompetensi
// Group key: (CoacheeName, Kompetensi, SubKompetensi) — finest grouping unit for boundary check
var finestGroups = data
    .GroupBy(item => new { item.CoacheeName, item.Kompetensi, item.SubKompetensi })
    .ToList();

// Slice groups into pages, never splitting a group
var pagesGroups = new List<List<TrackingItem>>();
var currentPageItems = new List<TrackingItem>();
int currentRowCount = 0;

foreach (var group in finestGroups)
{
    int groupSize = group.Count();
    // Start a new page if adding this group would exceed target AND we already have rows
    if (currentRowCount > 0 && currentRowCount + groupSize > targetRowsPerPage)
    {
        pagesGroups.Add(new List<TrackingItem>(currentPageItems));
        currentPageItems = new List<TrackingItem>();
        currentRowCount = 0;
    }
    currentPageItems.AddRange(group);
    currentRowCount += groupSize;
}
if (currentPageItems.Count > 0)
    pagesGroups.Add(currentPageItems);

int totalPages = Math.Max(1, pagesGroups.Count);
// Clamp page number
if (pageNumber > totalPages) pageNumber = totalPages;

// Slice data to current page
var paginatedData = pageNumber >= 1 && pageNumber <= pagesGroups.Count
    ? pagesGroups[pageNumber - 1]
    : new List<TrackingItem>();

// Compute display row range (1-based, based on full data positions)
int pageFirstRow = 0;
int pageLastRow = 0;
if (pagesGroups.Count > 0 && pageNumber >= 1 && pageNumber <= pagesGroups.Count)
{
    pageFirstRow = pagesGroups.Take(pageNumber - 1).Sum(p => p.Count) + 1;
    pageLastRow = pageFirstRow + paginatedData.Count - 1;
}

// Replace data with paginated slice (summary stats already computed from full `progresses`)
data = paginatedData;
```

**3. After the existing summary stats block (lines ~1584-1598), ADD these ViewBag fields:**

After `pendingApprovals = progresses.Count(p => p.Status == "Submitted");` block, add:

```csharp
// --- ViewBag: pagination state (UI-04) ---
ViewBag.CurrentPage = pageNumber;
ViewBag.TotalPages = totalPages;
ViewBag.PageFirstRow = pageFirstRow;
ViewBag.PageLastRow = pageLastRow;
// FilteredCount = total rows across all pages (before pagination); keep existing assignment below
```

**4. Replace the existing ViewBag.FilteredCount assignment** (currently `ViewBag.FilteredCount = data.Count;` at line ~1622). It must now use the FULL count before pagination. Change it to:

```csharp
ViewBag.FilteredCount = progresses.Count; // total rows across all pages (for "Menampilkan X-Y dari Z" display)
```

Note: `data.Count` after pagination would give the page size, not the total. The `ViewBag.FilteredCount` was set at line ~1622 AFTER the `data` mapping but before pagination was introduced. With pagination in place, use `progresses.Count` (the full materialized list) here.

**5. Replace the existing EmptyMessage logic** (lines ~1652-1656, the simple `if (data.Count == 0) { ViewBag.EmptyMessage = "..." }`) with scenario-aware detection:

```csharp
// --- Empty state scenario detection (UI-02) ---
// Detect BEFORE pagination so we check the full dataset count
// `progresses.Count` = full filtered dataset (0 means no results for current filter)
// `scopedCoacheeIds.Count` = whether the user has any coachees in scope at all
string emptyScenario = "";
if (progresses.Count == 0)
{
    if (scopedCoacheeIds.Count == 0)
    {
        // No coachees assigned at all (role scope is empty)
        emptyScenario = "no_coachees";
    }
    else if (!string.IsNullOrEmpty(bagian) || !string.IsNullOrEmpty(unit) ||
             !string.IsNullOrEmpty(trackType) || !string.IsNullOrEmpty(tahun) ||
             !string.IsNullOrEmpty(targetCoacheeId))
    {
        // Coachees exist but active filters narrow to zero results
        emptyScenario = "no_filter_match";
    }
    else
    {
        // Coachees exist, no filters active, but no deliverables yet
        emptyScenario = "no_deliverables";
    }
}
ViewBag.EmptyScenario = emptyScenario;
// Keep backward-compat: remove the old ViewBag.EmptyMessage assignment entirely
```

Remove the old `if (data.Count == 0) { ViewBag.EmptyMessage = "..." }` block entirely.

**IMPORTANT — Order of operations in the action:**
1. Lines 1537-1541: `var progresses = await query...ToListAsync();` ← keep
2. Lines ~1560-1581: `data = progresses.Select(...)` mapping ← keep
3. INSERT: Pagination block (groups → pages → slice data → compute pageFirstRow/pageLastRow)
4. Lines ~1584-1598: Summary stats from `progresses` ← keep (uses full list, not paginated)
5. Lines ~1600+: ViewBag filter lists ← keep
6. REPLACE: `ViewBag.FilteredCount = data.Count;` → `ViewBag.FilteredCount = progresses.Count;`
7. ADD: `ViewBag.CurrentPage`, `ViewBag.TotalPages`, `ViewBag.PageFirstRow`, `ViewBag.PageLastRow`
8. REPLACE: Old EmptyMessage block with EmptyScenario detection (uses `progresses.Count`, not `data.Count`)
9. Line 1658: `return View(data);` ← keep (now passes paginated data)
  </action>
  <verify>
    <automated>cd "C:/Users/Administrator/Desktop/PortalHC_KPB/.claude/worktrees/terminal-a" && dotnet build --configuration Release -v quiet 2>&1 | tail -5</automated>
  </verify>
  <done>
- Build succeeds with 0 errors
- ProtonProgress action signature includes `int page = 1`
- ViewBag.CurrentPage, ViewBag.TotalPages, ViewBag.PageFirstRow, ViewBag.PageLastRow, ViewBag.EmptyScenario are all set
- ViewBag.FilteredCount uses `progresses.Count` (full dataset count, not per-page count)
- Old ViewBag.EmptyMessage assignment is removed
- `return View(data)` passes the paginated slice
  </done>
</task>

</tasks>

<verification>
- Run `dotnet build --configuration Release` — must succeed with 0 errors
- Grep for `ViewBag.CurrentPage` in CDPController.cs — must appear
- Grep for `ViewBag.EmptyScenario` in CDPController.cs — must appear
- Grep for `ViewBag.EmptyMessage` in CDPController.cs — must NOT appear (removed)
- Grep for `int page = 1` in CDPController.cs in the ProtonProgress signature — must appear
</verification>

<success_criteria>
ProtonProgress action returns paginated `data` to the view, with ViewBag fields for pagination state and empty state scenario. Summary stats still computed from full `progresses`. Build passes 0 errors.
</success_criteria>

<output>
After completion, create `.planning/phases/66-ui-polish/66-01-SUMMARY.md`
</output>
